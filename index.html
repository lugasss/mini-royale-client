<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MINI ROYALE ‚Äî Deck Builder</title>
  <style>
    :root{
      --bg-1:#0f1724; --bg-2:#081425; --accent:#6ee7b7; --muted:#9aa6b2;
      --card-width:120px; --card-height:170px;
      --gold-color:#ffcc00; --gem-color:#00e0ff;
      --trophy-color: #ff9800; /* Orange for trophies */
      --tower-color: #60a5fa;
      --placement-line-color: rgba(110, 231, 183, 0.7);
      --elixir-color: #2196f3;
      --arena-color-dark: #102434;
      --arena-color-light: #081e2a;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, Arial; background: linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:#e6f0f2;}
    .stage{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden;}
    .app{width:min(1400px,96vw);height:calc(min(800px,86vh));background:linear-gradient(90deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));border-radius:18px;box-shadow:0 10px 40px rgba(0,0,0,0.6);display:flex;gap:20px;padding:20px; position: relative;}

    .sidebar{width:340px;padding:18px;display:flex;flex-direction:column;gap:12px}
    .logo{width:72px;height:72px;border-radius:14px;background:linear-gradient(135deg,var(--accent),#60a5fa);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:20px;color:#072127;box-shadow:0 6px 18px rgba(0,0,0,0.5);}
    h1{margin:0;font-size:22px;letter-spacing:1px}
    .subtitle{color:var(--muted);font-size:13px}

    .menu{margin-top:8px;display:flex;flex-direction:column;gap:8px}
    .menu button{
        background:#07132233;border:1px solid rgba(255,255,255,0.04);padding:12px 14px;color:inherit;border-radius:10px;cursor:pointer;text-align:left;
        transition: background 0.2s, transform 0.1s;
        display: flex; align-items: center; justify-content: space-between;
    }
    .menu button:hover:not(:disabled){background:#07132266; transform: translateY(-1px);}
    .menu button:disabled{opacity: 0.5; cursor: not-allowed;}
    
    /* New Trophy Display in Sidebar */
    .trophy-display-sidebar{
        font-weight: bold;
        padding: 8px 14px;
        background: linear-gradient(90deg, rgba(255, 152, 0, 0.2), transparent);
        border: 1px solid var(--trophy-color);
        border-radius: 10px;
        color: var(--trophy-color);
        text-align: center;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1em;
    }


    .deck-preview{margin-top:auto;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:12px}
    .deck-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-top:10px}
    .slot{width:100%;height:60px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px dashed rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted)}

    .main{flex:1;display:flex;flex-direction:column;gap:12px}
    .top-controls{display:flex;justify-content:space-between;align-items:center}
    
    .currency-display{display:flex;gap:15px; align-items: center;} /* Align items for settings button */
    .currency-item{font-weight:bold; padding: 4px 8px; background: rgba(255,255,255,0.05); border-radius: 6px;}

    .board{flex:1;display:flex;gap:12px;align-items:stretch}

    /* PAGED CARD POOL & DECK EDITOR (Unchanged structure) */
    .cards-pool{width:520px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:12px;display:flex;flex-direction:column}
    .pool-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;flex:1;overflow:hidden}
    .card.locked{opacity: 0.4; pointer-events: none; position: relative;}
    .card.locked::after{content: 'üîí Unlock in Shop'; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-weight: bold;}
    .page-controls{display:flex;justify-content:center;gap:8px;margin-top:10px}
    .page-btn{padding:6px 10px;background:#07132255;border-radius:6px;cursor:pointer;border:1px solid rgba(255,255,255,0.05)}
    .deck-editor{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;padding:12px;display:flex;flex-direction:column}
    .deck-slots{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px}
    .deck-slot{height:120px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px dashed rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;position:relative}

    /* Card Styling */
    .card{width:var(--card-width);height:var(--card-height);border-radius:12px;cursor:grab;user-select:none;box-shadow:0 6px 20px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.05);overflow:hidden;transition:transform .14s}
    .card:hover{transform:translateY(-6px) scale(1.02)}
    .art{height:60%;display:flex;align-items:center;justify-content:center;font-size:34px}
    .meta{padding:8px;display:flex;justify-content:space-between;align-items:center}
    
    /* SHOP STYLES */
    .shop{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;padding:12px;display:none;flex-direction:column}
    .shop-items{display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 20px;}
    .shop-chest{background:rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; display: flex; flex-direction: column; align-items: center; text-align: center;}
    .shop-chest h4{margin: 0 0 10px 0;}
    .shop-chest p{font-size: 14px; color: var(--muted);}
    .chest-buy button, .gold-to-gems button{padding: 10px 20px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; background: var(--gem-color); color: #072127; transition: transform 0.1s;}
    .chest-buy button:hover, .gold-to-gems button:hover{transform: translateY(-2px);}
    .gold-to-gems{background:rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; text-align: center; margin-top: 10px;}

    /* Multiplayer Game Board */
    .game-board{flex:1; display: none; flex-direction: column; overflow: hidden; position: relative;}
    
    #arena{flex:1; position: relative; background: linear-gradient(180deg, var(--arena-color-dark) 0%, var(--arena-color-light) 100%); border-radius: 12px 12px 0 0; overflow: hidden; border: 2px solid #334155; }
    
    /* Placement Boundary Line */
    #placementLine{position: absolute; left: 0; width: 100%; height: 4px; background: var(--placement-line-color); top: 50%; transform: translateY(-50%); transition: top 0.5s ease-in-out, background 0.5s;}

    /* Arena Aesthetics - The River/Bridge */
    #arena::before{content: ''; position: absolute; left: 50%; top: 48%; width: 120px; height: 40px; background: #0c334b; border: 3px solid #005a8b; border-radius: 10px; transform: translate(-50%, -50%); z-index: 1;} 
    #arena::after{content: ''; position: absolute; left: 50%; top: 50%; width: 2px; height: 100%; background: #0f172a; transform: translateX(-50%); z-index: 0;} 
    
    /* Arena Side Details (Banks/Paths) */
    .arena-bank-l, .arena-bank-r{
        position: absolute; width: 15%; height: 100%; top: 0;
        background: repeating-linear-gradient(135deg, rgba(30, 40, 50, 0.4), rgba(30, 40, 50, 0.4) 10px, rgba(40, 50, 60, 0.4) 10px, rgba(40, 50, 60, 0.4) 20px);
        border-right: 2px solid #334155;
        z-index: 1; 
        box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    }
    .arena-bank-l{left: 0; border-right: none; border-left: 2px solid #334155;}
    .arena-bank-r{right: 0;}
    /* Arena decoration fade (Existing) */
    .arena-decoration{position: absolute; width: 100%; height: 50%; pointer-events: none; opacity: 0.2; transition: opacity 0.5s;}
    #opponentSide{top: 0; background: linear-gradient(rgba(255, 0, 0, 0.1), transparent);}
    #playerSide{bottom: 0; background: linear-gradient(transparent, rgba(0, 255, 255, 0.1));}


    .tower{position: absolute; width: 60px; height: 80px; background: var(--tower-color); border: 2px solid #005a8b; border-radius: 8px 8px 0 0; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.5); transition: opacity 0.5s, transform 0.5s; z-index: 2;}
    .tower.king{height: 100px; width: 80px; background: linear-gradient(180deg, #5c4b63, #382d43); z-index: 3;} 
    .tower.princess{z-index: 2;}
    .tower .health-bar{width: 80%; height: 5px; background: red; margin-bottom: 3px; border-radius: 2px;}
    .tower .health-fill{height: 100%; background: limegreen; transition: width 0.3s;}
    .tower.destroyed{opacity: 0.3; transform: scale(0.9); pointer-events: none;}
    
    .tower.king .icon{font-size: 30px;}
    .tower.princess .icon{font-size: 20px;}
    
    /* Tower Projectile Visual */
    .projectile{
        position: absolute;
        width: 10px; height: 10px;
        border-radius: 50%;
        background: yellow;
        z-index: 30;
        transition: transform 0.05s linear;
        pointer-events: none;
    }
    .projectile.cannon{
        width: 16px; height: 16px;
        background: #4a4a4a;
        border: 2px solid #fff;
    }


    /* Placed Unit Style - Base */
    .unit{
        position: absolute;
        display: flex; flex-direction: column; align-items: center; justify-content: center; 
        font-size: 20px;
        color: white;
        font-weight: bold;
        border: 3px solid; 
        transition: transform 0.1s, box-shadow 0.1s;
        z-index: 10;
        pointer-events: none; 
    }

    /* Unit Health Bar */
    .unit-health-bar{
        position: absolute;
        top: -10px;
        width: 80%;
        height: 3px;
        background: red;
        border-radius: 1px;
    }
    .unit-health-fill{
        height: 100%;
        background: limegreen;
        transition: width 0.1s;
    }

    .unit .cost{ display: none; } 

    /* Player UI at the bottom of the board */
    #playerUI{height: 120px; background: rgba(0,0,0,0.4); border-radius: 0 0 12px 12px; padding: 10px; display: flex; gap: 10px; align-items: center; border-top: 2px solid #334155;}
    
    #timerDisplay{width: 80px; font-size: 20px; font-weight: bold; color: var(--gold-color); text-align: center; background: rgba(0,0,0,0.6); padding: 5px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.1);}
    
    /* Forfeit Button Style */
    #forfeitBtn{
        background: #e74c3c;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.1s;
        align-self: flex-start;
        margin-left: auto;
    }
    #forfeitBtn:hover{transform: translateY(-2px);}
    
    #elixirDisplay{width: 150px; height: 100%; background: rgba(255,255,255,0.05); border-radius: 8px; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; border: 1px solid rgba(255,255,255,0.1);}
    #elixirBar{width: 90%; height: 60%; background: rgba(0,0,0,0.5); border-radius: 6px; position: relative; overflow: hidden;}
    #elixirFill{height: 100%; width: 0%; background: linear-gradient(90deg, #42a5f5, var(--elixir-color)); border-radius: 6px; transition: width 0.3s linear;}
    #elixirCounter{font-size: 24px; font-weight: bold; color: var(--elixir-color); margin-top: 5px; text-shadow: 0 0 5px rgba(33, 150, 243, 0.8);}
    .elixir-drop{position: absolute; top: 0; bottom: 0; width: 10%; background: radial-gradient(circle at 70% 30%, rgba(255, 255, 255, 0.5), transparent);}
    
    #handDisplay{flex: 1; height: 100%; display: flex; gap: 10px; align-items: center; justify-content: center;}
    .hand-card-container{
        width: 100px; height: 100%; perspective: 1000px;
        transition: transform 0.2s;
    }
    .hand-card-container:hover{transform: translateY(-5px) scale(1.05);}

    .hand-card {
        width: 100%; height: 100%; border-radius: 8px; background: #071322; 
        border: 2px solid rgba(255,255,255,0.2); box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        display: flex; flex-direction: column; align-items: center; justify-content: center; 
        cursor: pointer; 
        user-select: none;
        position: relative; overflow: hidden;
        transition: opacity 0.2s, box-shadow 0.2s, border 0.2s, transform 0.2s;
    }
    .hand-card.selected {
        box-shadow: 0 0 15px 5px var(--accent) !important;
        border: 4px solid var(--accent) !important;
        transform: translateY(-8px) scale(1.1);
    }

    .hand-card .cost-badge{
        position: absolute; top: 5px; right: 5px; 
        background: rgba(0,0,0,0.6); color: var(--gold-color); 
        border-radius: 50%; width: 20px; height: 20px; 
        display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;
    }
    .hand-card .card-emoji{font-size: 34px;}

    .hand-card.not-enough-elixir {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    /* Status Message Fade */
    #statusMessage{
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
        background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 8px; z-index: 100; 
        color: #6ee7b7; font-weight: bold;
        transition: opacity 2s ease-out; 
        opacity: 1;
        pointer-events: none;
    }

    /* --- MODAL STYLES --- */
    .modal-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        border-radius: 18px;
    }
    .modal-content {
        background: var(--bg-1);
        padding: 30px;
        border-radius: 15px;
        width: min(700px, 90%);
        max-height: 80%;
        overflow-y: auto;
        box-shadow: 0 10px 50px rgba(0, 0, 0, 0.7);
        border: 2px solid var(--accent);
    }
    .modal-content h2 {
        color: var(--accent);
        margin-top: 0;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 10px;
        margin-bottom: 20px;
    }
    .close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 24px;
        color: var(--muted);
        cursor: pointer;
        background: none;
        border: none;
        padding: 5px;
        line-height: 1;
        transition: color 0.2s;
    }
    .close-btn:hover {
        color: #fff;
    }

    /* Arena Modal Specific Styles */
    .arena-list {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    .arena-item {
        padding: 15px;
        border-radius: 10px;
        color: #fff;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .arena-item.current-arena {
        border-color: var(--trophy-color);
        box-shadow: 0 0 15px rgba(255, 152, 0, 0.5);
    }
    .arena-item h3 {
        margin: 0;
        font-size: 1.5em;
        text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .arena-item p {
        margin: 5px 0;
        font-size: 0.9em;
    }
    .arena-item .trophy-req {
        font-weight: bold;
        color: var(--trophy-color);
    }
    .arena-item .unlocked-cards {
        margin-top: 10px;
        font-size: 0.9em;
        color: var(--accent);
        font-weight: 500;
    }
    .arena-item.locked {
        opacity: 0.5;
    }
    
    /* Friends Modal Styles */
    .friend-tabs {
        display: flex;
        margin-bottom: 20px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .friend-tabs button {
        flex: 1;
        padding: 10px 15px;
        background: none;
        border: none;
        color: var(--muted);
        font-weight: bold;
        cursor: pointer;
        transition: color 0.2s, border-bottom 0.2s;
    }
    .friend-tabs button.active {
        color: var(--accent);
        border-bottom: 2px solid var(--accent);
    }
    .friend-list-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
        background: rgba(255,255,255,0.03);
        border-radius: 8px;
        margin-bottom: 10px;
    }
    .friend-actions button {
        margin-left: 8px;
        padding: 6px 12px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.1s;
    }
    .friend-info {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    /* Chat/Message Styles */
    .chat-container {
        display: flex;
        height: 400px;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        overflow: hidden;
    }
    .chat-sidebar {
        width: 180px;
        background: rgba(255,255,255,0.05);
        overflow-y: auto;
    }
    .chat-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: rgba(0,0,0,0.2);
    }
    .chat-message-area {
        flex: 1;
        padding: 10px;
        overflow-y: auto;
    }
    .chat-input-area {
        display: flex;
        padding: 10px;
        border-top: 1px solid rgba(255,255,255,0.1);
    }
    #chatInput {
        flex: 1;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid #475569;
        background: #0f172a;
        color: white;
    }
    #sendMsgBtn {
        margin-left: 8px;
        background: var(--accent);
        color: #0f172a;
    }
    .chat-list-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid rgba(0,0,0,0.2);
    }
    .chat-list-item:hover, .chat-list-item.active {
        background: var(--bg-1);
    }
    .message-bubble {
        padding: 8px 12px;
        border-radius: 15px;
        margin-bottom: 10px;
        max-width: 70%;
        line-height: 1.4;
    }
    .message-you {
        background: #60a5fa;
        color: white;
        margin-left: auto;
        border-bottom-right-radius: 0;
    }
    .message-friend {
        background: #34495e;
        color: white;
        margin-right: auto;
        border-bottom-left-radius: 0;
    }
    #emojiPicker {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 5px;
    }
    #emojiPicker button {
        font-size: 1.5em;
        background: none;
        border: none;
        cursor: pointer;
    }

  </style>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
  <div class="stage">
    <div class="app">

      <aside class="sidebar">
        <div class="brand"><div class="logo">MR</div><div><h1>MINI ROYALE</h1><div class="subtitle">Deck editor</div></div></div>
        
        <div id="trophyDisplay" class="trophy-display-sidebar">
             üèÜ 0
        </div>

        <div class="menu">
          <button id="playBtn">‚ñ∂ Play Game (MP)</button>
          
          <button id="profileBtn">üë§ Profile</button>
          
          <button id="friendsBtn">üë• Friends</button>

          <button id="shopBtn">üíé Shop</button>
          <button id="deckEditorBtn">üÉè Deck Editor</button>
          <button id="arenasBtn">üèÜ Arenas</button>
          <button id="updateLogBtn">üìú Update Logs</button>
        </div>

        <div class="deck-preview">
          <strong>Current Deck (Avg. Elixir: <span id="avgCost">‚Äî</span>)</strong>
          <div class="deck-grid" id="deckPreview"></div>
        </div>
      </aside>

      <main class="main">
        <div class="top-controls">
          <div class="current-view-title" id="userNameDisplay"></div>
          <div class="currency-display">
            <button id="settingsBtn" style="background: none; border: none; font-size: 1.2em; color: var(--muted); cursor: pointer; margin-right: 15px; transition: color 0.2s;">‚öôÔ∏è</button>
            <div class="currency-item" id="goldDisplay">üí∞ 1000</div>
            <div class="currency-item" id="gemsDisplay">üíé 50</div>
          </div>
        </div>

        <div class="board">
          
          <section class="cards-pool" id="cardsPool">
            <h3>Cards</h3>
            <div class="pool-grid" id="poolGrid"></div>
            <div class="page-controls">
              <div class="page-btn" id="prevPage">‚óÄ</div>
              <div class="page-btn" id="nextPage">‚ñ∂</div>
            </div>
          </section>

          <section class="deck-editor" id="deckEditor">
            <h3>Deck (8 Slots)</h3>
            <div class="deck-slots" id="deckSlots"></div>
          </section>

          <section class="shop" id="shopView">
            <h3>The Royal Shop</h3>
            <div class="shop-items">
              
              <div class="shop-chest">
                  <div class="chest-info">
                      <h4>Tag Chest</h4>
                      <p>Unlocks one new, random Player Tag. (Rarities defined in JS)</p>
                  </div>
                  <div class="chest-buy">
                      <button onclick="buyTagChest()">üíé 100</button>
                  </div>
              </div>
              
              <div class="shop-chest">
                <div class="chest-info">
                  <h4>Bronze Chest</h4>
                  <p>Unlocks 1 random locked card.</p>
                </div>
                <div class="chest-buy">
                  <button onclick="buyChest(1, 50)">üíé 50</button>
                </div>
              </div>

              <div class="shop-chest">
                <div class="chest-info">
                  <h4>Silver Chest</h4>
                  <p>Unlocks 2 random locked cards.</p>
                </div>
                <div class="chest-buy">
                  <button onclick="buyChest(2, 120)">üíé 120</button>
                </div>
              </div>

              <div class="shop-chest">
                <div class="chest-info">
                  <h4>Gold Chest</h4>
                  <p>Unlocks 3 random locked cards.</p>
                </div>
                <div class="chest-buy">
                  <button onclick="buyChest(3, 250)">üíé 250</button>
                </div>
              </div>
              
              <div class="gold-to-gems">
                  <h4>Exchange Gold for Gems</h4>
                  <p>1000 Gold for 100 Gems</p>
                  <button style="background:linear-gradient(135deg,#ffcc00,#b08e00); margin-top: 8px;" onclick="exchangeGold(1000, 100)">Exchange üí∞ 1000</button>
              </div>

            </div>
          </section>

          <section class="game-board" id="gameBoard">
            <div id="arena">
                <div class="arena-bank-l"></div>
                <div class="arena-bank-r"></div>
                
                <div id="opponentSide" class="arena-decoration"></div> 
                <div id="playerSide" class="arena-decoration"></div> 
                <div id="placementLine"></div>
                <div id="unitContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div> 
                <p id="statusMessage" style="opacity:0;"></p>
            </div>
            <div id="playerUI">
              <div id="timerDisplay">3:00</div>
              <div id="elixirDisplay">
                <div id="elixirBar">
                  <div id="elixirFill"></div>
                </div>
                <div id="elixirCounter">0 / 10</div>
              </div>
              <div id="handDisplay">
                </div>
                <button id="forfeitBtn" style="display: none;">üè≥Ô∏è Forfeit</button>
            </div>
          </section>
        </div>
      </main>

      <div id="updateLogModal" class="modal-overlay">
          <div class="modal-content">
              <h2>üìú Update Logs</h2>
              <button class="close-btn" onclick="document.getElementById('updateLogModal').style.display='none';">‚úñ</button>
              <div id="logContent"></div>
          </div>
      </div>
      
      <div id="arenasModal" class="modal-overlay">
          <div class="modal-content">
              <h2>üèÜ Arena Progress</h2>
              <button class="close-btn" onclick="document.getElementById('arenasModal').style.display='none';">‚úñ</button>
              <div id="arenaContent"></div>
          </div>
      </div>

      <div id="profileModal" class="modal-overlay">
          <div class="modal-content">
              <h2>üë§ Player Profile</h2>
              <button class="close-btn" onclick="document.getElementById('profileModal').style.display='none';">‚úñ</button>
              <div id="profileContent"></div>
          </div>
      </div>

      <div id="settingsModal" class="modal-overlay">
          <div class="modal-content">
              <h2>‚öôÔ∏è Settings</h2>
              <button class="close-btn" onclick="document.getElementById('settingsModal').style.display='none';">‚úñ</button>
              <div id="settingsContent">
                  
                  <div style="margin-bottom: 20px; padding: 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                      <h4>Change Username</h4>
                      <input type="text" id="newUsernameInput" placeholder="Enter new username (3-15 chars)" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #475569; background: #0f172a; color: white;">
                      <button onclick="changeUsername()" style="margin-top: 10px; padding: 8px 15px; border: none; border-radius: 5px; background: var(--accent); color: #0f172a; cursor: pointer; font-weight: bold;">Save Username</button>
                  </div>
                  
                  <div style="margin-bottom: 20px; padding: 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                      <h4>Change Profile Picture</h4>
                      <div id="profilePicPreview" style="font-size: 40px; margin-bottom: 10px;">üë§</div>
                      <button onclick="changeProfilePic()" style="padding: 8px 15px; border: none; border-radius: 5px; background: #60a5fa; color: white; cursor: pointer; font-weight: bold;">Random Emoji</button>
                  </div>
                  
                  <div style="margin-bottom: 20px; padding: 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                      <h4>Change Player ID (One-time Use)</h4>
                      <p id="idChangeStatus" style="font-size: 0.9em; color: orange;">Status: Checking...</p>
                      <button id="changeIdBtn" onclick="changePlayerId()" style="padding: 8px 15px; border: none; border-radius: 5px; background: #e74c3c; color: white; cursor: pointer; font-weight: bold;">Change ID</button>
                  </div>

                  <div style="margin-bottom: 20px; padding: 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                      <h4>Equip Player Tag</h4>
                      <div id="equippedTagPreview" style="font-size: 1.1em; margin-bottom: 10px; font-weight: bold;"></div>
                      <select id="tagSelect" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #475569; background: #0f172a; color: white;">
                          </select>
                      <button onclick="equipSelectedTag()" style="margin-top: 10px; padding: 8px 15px; border: none; border-radius: 5px; background: var(--accent); color: #0f172a; cursor: pointer; font-weight: bold;">Equip Tag</button>
                  </div>
              </div>
          </div>
      </div>
      
      <div id="friendsModal" class="modal-overlay">
          <div class="modal-content" style="max-width: 800px;">
              <h2>üë• Friends & Social</h2>
              <button class="close-btn" onclick="document.getElementById('friendsModal').style.display='none';">‚úñ</button>
              
              <div class="friend-tabs">
                  <button id="tabFriendsList" class="active" onclick="switchFriendsTab('friendsList')">Friends List</button>
                  <button id="tabAddBlock" onclick="switchFriendsTab('addBlock')">Add / Block</button>
                  <button id="tabChat" onclick="switchFriendsTab('chat')">Chat</button>
              </div>

              <div id="friendsListContent" class="tab-content">
                  <p id="friendCountDisplay" style="font-weight: bold; margin-bottom: 15px;"></p>
                  <div id="friendListContainer">
                      </div>
              </div>
              
              <div id="addBlockContent" class="tab-content" style="display: none;">
                  <div style="border: 1px solid rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                      <h4>Add Friend (by Username or ID)</h4>
                      <input type="text" id="friendInput" placeholder="Enter Username or ID (e.g., MR-ABCDE)" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #475569; background: #0f172a; color: white;">
                      <button onclick="addFriendFromInput()" style="margin-top: 10px; padding: 8px 15px; border: none; border-radius: 5px; background: #2ecc71; color: white; cursor: pointer; font-weight: bold;">Send Request</button>
                  </div>
                  
                  <div style="border: 1px solid rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                      <h4>Blocked Players</h4>
                      <div id="blockedListContainer">
                          </div>
                  </div>
              </div>

              <div id="chatContent" class="tab-content" style="display: none;">
                  <div class="chat-container">
                      <div class="chat-sidebar" id="chatSidebar">
                          </div>
                      <div class="chat-main">
                          <h4 id="chatHeader" style="margin: 0; padding: 10px; background: rgba(0,0,0,0.3); color: var(--accent);">Select a Friend to Chat</h4>
                          <div class="chat-message-area" id="chatMessages">
                              </div>
                          <div class="chat-input-area">
                              <input type="text" id="chatInput" placeholder="Type a message..." disabled>
                              <button id="sendMsgBtn" onclick="sendMessage()" disabled>Send</button>
                          </div>
                          <div id="emojiPicker">
                              </div>
                      </div>
                  </div>
                  <div style="margin-top: 15px; display: flex; gap: 10px;">
                      <input type="number" id="giftGoldAmount" placeholder="Gold amount (max 5000)" min="1" max="5000" style="padding: 8px; border-radius: 5px; border: 1px solid #475569; background: #0f172a; color: white; width: 25%;">
                      <button onclick="giftCurrencyWrapper('gold')" style="padding: 8px 15px; border: none; border-radius: 5px; background: var(--gold-color); color: #0f172a; cursor: pointer; font-weight: bold;">Gift Gold üí∞</button>
                      <input type="number" id="giftGemAmount" placeholder="Gem amount (max 500)" min="1" max="500" style="padding: 8px; border-radius: 5px; border: 1px solid #475569; background: #0f172a; color: white; width: 25%;">
                      <button onclick="giftCurrencyWrapper('gems')" style="padding: 8px 15px; border: none; border-radius: 5px; background: var(--gem-color); color: #0f172a; cursor: pointer; font-weight: bold;">Gift Gems üíé</button>
                  </div>
              </div>
          </div>
      </div>


    </div>
  </div>

  <audio id="clickSound" src="https://assets.mixkit.co/sfx/download/mixkit-modern-click-box-check-1077.wav"></audio>
  <audio id="gameStartSound" src="https://assets.mixkit.co/sfx/download/mixkit-game-level-opener-2324.wav"></audio>
  <audio id="towerAttackSound" src="https://assets.mixkit.co/sfx/download/mixkit-small-hit-with-a-sword-2151.wav"></audio>

  <script>
    // --- COMBAT CONSTANTS ---
    const PRINCESS_TOWER_DAMAGE = 80;
    const KING_TOWER_DAMAGE = 250;
    const TOWER_RANGE = 400; 
    const PRINCESS_ATTACK_RATE = 30; 
    const KING_ATTACK_RATE = 60; 

    // --- TROPHY CONSTANTS ---
    const TROPHY_WIN = 30;
    const TROPHY_LOSS = -30;
    const TROPHY_FORFEIT_LOSS = -50;
    
    // --- REFUND CONSTANTS ---
    const REFUND_GOLD_PER_ELIXIR = 50;

    // --- NEW: TAG & BLACKLIST CONSTANTS ---
    const BLACKLISTED_WORDS = [
        'swear', 'badword', 'racist', 'nword', 'asshole', 'bitch', 'fuck', 'shit', 'cunt',
        'idiot', 'loser', 'trash', 'dumb', 'gay', 
    ];

    const TAG_CHEST_COST = 100;
    const TAG_RARITIES = [
        { name: 'Rookie', emoji: 'üî∞', rarity: 40, color: '#9aa6b2' },
        { name: 'Veteran', emoji: '‚öîÔ∏è', rarity: 20, color: '#f1c40f' },
        { name: 'Elite', emoji: '‚ú®', rarity: 15, color: '#3498db' },
        { name: 'Clasher', emoji: 'üí•', rarity: 10, color: '#e74c3c' },
        { name: 'DeckMaster', emoji: 'üÉè', rarity: 5, color: '#2ecc71' },
        { name: 'Royal', emoji: 'üëë', rarity: 4, color: '#ffcc00' },
        { name: 'Legend', emoji: 'üî•', rarity: 3, color: '#e67e22' },
        { name: 'Mythic', emoji: 'üîÆ', rarity: 2, color: '#9b59b6' },
        { name: 'GigaChad', emoji: 'üóø', rarity: 0.5, color: '#f39c12' },
        { name: 'AlphaTool', emoji: 'ü§ñ', rarity: 0.5, color: '#6ee7b7' }
    ];
    const CREATOR_TAG = { name: 'CREATOR', emoji: 'üåü', color: 'red' }; 
    const TAG_NONE = { name: 'None', emoji: '', color: 'transparent' };

    // --- NEW: Friends System Constants ---
    const MAX_GIFT_GEMS = 500;
    const MAX_GIFT_GOLD = 5000;
    const MESSAGE_EMOJIS = ['üòÇ', 'üò≠', 'üòé', 'üëç', '‚ù§Ô∏è', 'üî•', 'üéâ', 'ü§Ø'];

    // --- GAME DATA SETUP ---
    const CARD_TEMPLATES = [];
    const names = ['Knight','Archer','Giant','Wizard','Bomber','Spear Goblins','Mini P.E.K.K.A','Skeleton Army','Valkyrie','Hog Rider','Fireball','Zap','Goblin Barrel','Tesla','Inferno Tower','Prince','Mega Minion','Freeze','Tesla Charge','Royal Giant'];
    const emojis = ['üõ°Ô∏è','üèπ','üëä','ü™Ñ','üí£','‚öîÔ∏è','üî©','üíÄ','ü•Ä','üêó','üî•','‚ö°','ü™ì','‚öôÔ∏è','üî•','üèá','ü¶Ö','‚ùÑÔ∏è','üîã','üëë'];

    const stats = [
        { name: 'Knight', cost: 3, hp: 1000, dmg: 120, range: 50, speed: 2, type: 'troop', unitCount: 1, attackRate: 60, unlockArenaId: 0 },
        { name: 'Archer', cost: 3, hp: 400, dmg: 150, range: 150, speed: 2, type: 'troop', unitCount: 2, attackRate: 60, unlockArenaId: 0 }, 
        { name: 'Giant', cost: 5, hp: 2500, dmg: 180, range: 50, speed: 1, type: 'troop', unitCount: 1, attackRate: 90, unlockArenaId: 0 },
        { name: 'Wizard', cost: 5, hp: 500, dmg: 250, range: 150, speed: 2, type: 'troop', unitCount: 1, attackRate: 75, unlockArenaId: 0 },
        { name: 'Bomber', cost: 3, hp: 350, dmg: 300, range: 150, speed: 2, type: 'troop', unitCount: 1, attackRate: 60, unlockArenaId: 0 },
        { name: 'Spear Goblins', cost: 2, hp: 300, dmg: 80, range: 150, speed: 3, type: 'troop', unitCount: 3, attackRate: 60, unlockArenaId: 0 }, 
        { name: 'Mini P.E.K.K.A', cost: 4, hp: 1100, dmg: 350, range: 50, speed: 3, type: 'troop', unitCount: 1, attackRate: 90, unlockArenaId: 0 },
        { name: 'Skeleton Army', cost: 3, hp: 1000, dmg: 50, range: 50, speed: 3, type: 'troop', unitCount: 10, attackRate: 60, unlockArenaId: 0 }, 
        { name: 'Valkyrie', cost: 4, hp: 1500, dmg: 200, range: 50, speed: 2, type: 'troop', unitCount: 1, attackRate: 60, unlockArenaId: 0 },
        { name: 'Hog Rider', cost: 4, hp: 1400, dmg: 260, range: 50, speed: 3, type: 'troop', unitCount: 1, attackRate: 75, unlockArenaId: 0 },
        { name: 'Fireball', cost: 4, hp: 0, dmg: 400, range: 0, speed: 0, type: 'spell', unitCount: 0, unlockArenaId: 0 },
        { name: 'Zap', cost: 2, hp: 0, dmg: 180, range: 0, speed: 0, type: 'spell', unitCount: 0, unlockArenaId: 0 },
        { name: 'Goblin Barrel', cost: 3, hp: 600, dmg: 100, range: 50, speed: 3, type: 'troop', unitCount: 3, attackRate: 60, unlockArenaId: 1 }, 
        { name: 'Tesla', cost: 4, hp: 1000, dmg: 150, range: 150, speed: 0, type: 'troop', unitCount: 1, attackRate: 60, unlockArenaId: 2 }, 
        { name: 'Inferno Tower', cost: 5, hp: 1500, dmg: 50, range: 400, speed: 0, type: 'troop', unitCount: 1, attackRate: 5, unlockArenaId: 3 }, 
        { name: 'Prince', cost: 5, hp: 1400, dmg: 280, range: 50, speed: 2, type: 'troop', unitCount: 1, attackRate: 90, unlockArenaId: 3 },
        { name: 'Mega Minion', cost: 3, hp: 600, dmg: 180, range: 150, speed: 2, type: 'troop', unitCount: 1, attackRate: 75, unlockArenaId: 4 },
        { name: 'Freeze', cost: 4, hp: 0, dmg: 0, range: 0, speed: 0, type: 'spell', unitCount: 0, unlockArenaId: 4 },
        { name: 'Tesla Charge', cost: 6, hp: 0, dmg: 600, range: 0, speed: 0, type: 'spell', unitCount: 0, unlockArenaId: 5 },
        { name: 'Royal Giant', cost: 6, hp: 2000, dmg: 220, range: 400, speed: 1, type: 'troop', unitCount: 1, attackRate: 75, unlockArenaId: 6 }, 
    ];

    stats.forEach((s, i) => {
        const unitCount = s.unitCount || 1;
        const unitHp = s.hp / unitCount; 
        
        CARD_TEMPLATES.push({
            id: i + 1,
            name: s.name,
            emoji: emojis[i],
            cost: s.cost,
            type: s.type,
            maxHp: s.hp,
            unitHp: unitHp, 
            unitCount: unitCount, 
            damage: s.dmg,
            range: s.range,
            speed: s.speed,
            attackRate: s.attackRate || 60,
            unlockArenaId: s.unlockArenaId 
        });
    });

    const FUNNY_NAMES = [
        "Royal Goober üëë", "Elixir Enthusiast üß™", "Goblin Giggle üòÇ", "Mega Nut ü•ú", 
        "P.E.K.K.A.'s Pet ü¶ã", "The Crying King üò≠", "Wizard Wisp ‚ú®", "Lumberjack Log ü™µ", 
        "Skeletor's Pal üíÄ", "Hog Rider Hog üêó", "Fireball Flipper üî•", "Zap Zapper ‚ö°",
        "Freeze Fanatic ü•∂", "Tesla's Tool ‚öôÔ∏è", "Inferno Burner üåã", "Prince's Pony üèá",
        "Minion Master üòà", "Clash Connoisseur üç∑", "Arena Ace ‚ô†Ô∏è", "Mighty Miner ‚õèÔ∏è",
        "Sparky Sprout üå±", "Electro Enforcer üîã", "Dart Devil üéØ", "Ice Cream Golem üç¶"
    ];
    
    // Profile Emoji List
    const PROFILE_EMOJIS = ['üòÄ', 'üòé', 'üòá', 'ü•≥', 'ü§ì', 'ü§ñ', 'üíÄ', 'üëΩ', 'ü§°', 'ü¶Å', 'ü¶Ñ', 'üê≤', 'üçÑ', 'üåü', '‚ö°', 'üèÜ', 'üçï', 'üé≤', 'üí£', 'üîÆ'];


    // Arena Unlock Helper - Map card IDs to Arena IDs
    const CARD_UNLOCK_MAP = {};
    CARD_TEMPLATES.forEach(card => {
        CARD_UNLOCK_MAP[card.id] = card.unlockArenaId;
    });

    // Arena Data
    const ARENAS = [
        { id: 0, name: "Training Grounds", minTrophies: 0, maxTrophies: 249, unlockCardIds: [], background: 'linear-gradient(135deg, #16a085, #1abc9c)' },
        { id: 1, name: "Goblin Garden", minTrophies: 250, maxTrophies: 499, unlockCardIds: [13], background: 'linear-gradient(135deg, #27ae60, #2ecc71)' }, 
        { id: 2, name: "P.E.K.K.A's Playhouse", minTrophies: 500, maxTrophies: 749, unlockCardIds: [14], background: 'linear-gradient(135deg, #2c3e50, #34495e)' }, 
        { id: 3, name: "Spooky Town", minTrophies: 750, maxTrophies: 999, unlockCardIds: [15, 16], background: 'linear-gradient(135deg, #8e44ad, #9b59b6)' }, 
        { id: 4, name: "Electric Valley", minTrophies: 1000, maxTrophies: 1499, unlockCardIds: [17, 18], background: 'linear-gradient(135deg, #f39c12, #f1c40f)' }, 
        { id: 5, name: "Legendary Arena", minTrophies: 1500, maxTrophies: 1999, unlockCardIds: [19], background: 'linear-gradient(135deg, #e74c3c, #c0392b)' }, 
        { id: 6, name: "Ultimate Champion", minTrophies: 2000, maxTrophies: Infinity, unlockCardIds: [20], background: 'linear-gradient(135deg, #3498db, #2980b9)' } 
    ];


    // Update Log Data (for completeness)
    const UPDATE_LOGS = [
        {
            version: '1.6',
            date: 'Dec 2024',
            changes: [
                'Added a new **Friends & Social System** with a dedicated modal.',
                'Implemented **Add/Unfriend** and **Block Player** functionality by Username or ID (mocked).',
                'Added a **Chat System** with **Emoji** support (mocked).',
                'Added **Gifting** functionality (max üí∞ 5000 Gold / üíé 500 Gems).'
            ]
        },
        {
            version: '1.5',
            date: 'Dec 2024',
            changes: [
                'Implemented **Username Profanity Filter** against a list of blacklisted words.',
                'Added **Player Tags** system, displayable next to the username.',
                'New **Tag Chest** added to the shop (üíé 100) for unlocking new tags based on rarity.',
                'Added a dedicated **CREATOR** tag (üåü) as a special, permanent unlock.'
            ]
        },
        {
            version: '1.4',
            date: 'Dec 2024',
            changes: [
                'Added a **Settings Menu** (‚öôÔ∏è icon next to Gold).',
                'Settings allow changing **Username** and **Profile Picture**.',
                'Implemented a **One-Time Player ID Change** feature in Settings.',
            ]
        },
        {
            version: '1.3',
            date: 'Dec 2024',
            changes: [
                'Added a detailed **Player Profile** with unique ID, stats, and max trophies.',
                'Implemented **Arena Card Restriction:** Cards from higher arenas are removed from your deck and refunded (50 Gold per Elixir Cost).',
                'Match results now track **Wins, Losses, and Forfeits**.'
            ]
        },
        {
            version: '1.2',
            date: 'Dec 2024',
            changes: [
                'Implemented **Trophy & Arena System** with 7 unique Arenas.',
                'Added a **Forfeit Button** during matches (losing 50 Trophies).',
                'Moved **Play Button** to the top of the sidebar.',
                'Added an **Arenas Button** to view progress and unlocks.',
                'Card Pool now shows cards locked by Trophies.'
            ]
        },
        {
            version: '1.1',
            date: 'Nov 2024',
            changes: [
                'Implemented **2D/3D Character Models** for all deployable units, giving them unique styles and colors.',
                'Added visual **Arena Side Details** to make the board look much cooler and more detailed.',
                '**Card Cycling Fix:** The game now uses a complete 8-card cycle, drawing from a full Draw Pile and shuffling the Discard Pile when empty.',
                '**King Tower Protection:** Troops will no longer attack the King Tower unless both Princess Towers have been destroyed.',
                '**Spell Placement:** All spell cards can now be placed anywhere on the map, including the opponent\'s territory.'
            ]
        },
        {
            version: '1.0',
            date: 'Oct 2024',
            changes: [
                'Initial game framework created: Deck Editor, Card Pool, and Shop systems.',
                'Core game logic implemented: Elixir generation, Tower placement, Unit movement, and basic combat simulation.',
                'Added Gold/Gem currency and purchasing mechanics for unlocking cards.',
                'Initial 4-card hand system and mock multiplayer interface established.'
            ]
        }
    ];
    
    /**
     * Maps card to specific visual styles for a more character-like 2D/3D look.
     */
    function getUnitStyle(card) {
        let style = {
            size: 40,
            baseColor: '#2c3e50',
            accentColor: '#bdc3c7',
            shape: '50%', 
            emoji: card.emoji
        };

        if (card.name === 'Knight') {
            style.size = 45; style.baseColor = '#4a69bd'; style.accentColor = '#2f3640';
            style.emoji = 'üõ°Ô∏è'; style.shape = '40%';
        } else if (card.name === 'Archer') {
            style.size = 35; style.baseColor = '#d63031'; style.accentColor = '#f5f6fa';
            style.emoji = 'üèπ';
        } else if (card.name === 'Giant') {
            style.size = 50; style.baseColor = '#7bed9f'; style.accentColor = '#2ed573';
            style.emoji = 'üëä'; style.shape = '30%';
        } else if (card.name === 'Wizard') {
            style.size = 40; style.baseColor = '#e84118'; style.accentColor = '#f5f6fa';
            style.emoji = 'üî•'; style.shape = '60%';
        } else if (card.name === 'Mini P.E.K.K.A') {
            style.size = 55; style.baseColor = '#8e44ad'; style.accentColor = '#34495e'; style.shape = '15%';
            style.emoji = 'ü§ñ'; 
        } else if (card.name === 'Skeleton Army' || card.name === 'Spear Goblins') {
            style.size = 25; style.baseColor = '#c8d6e5'; style.accentColor = '#57606f';
            style.emoji = 'üíÄ';
        } else if (card.name === 'Hog Rider') {
            style.size = 45; style.baseColor = '#ff6b81'; style.accentColor = '#c70039'; style.emoji = 'üêó';
        } else if (card.name === 'Valkyrie') {
            style.size = 45; style.baseColor = '#ffb300'; style.accentColor = '#800000'; style.emoji = 'ü•Ä';
        } else if (card.name === 'Royal Giant') {
            style.size = 60; style.baseColor = '#4298b5'; style.accentColor = '#1f3c5f'; style.emoji = 'üëë';
        } else if (card.type === 'spell') {
            style.size = 0;
        }

        return style;
    }

    function colorForId(id){return `linear-gradient(180deg,hsl(${(id*40)%360} 70% 48%),hsl(${(id*40+30)%360} 60% 35%))`}

// --- CORRECT GLOBAL DECLARATIONS (Around Line 967) ---

// --- CORRECT GLOBAL DECLARATIONS (Around Line 967) ---

// Line 969: Keep the server URL constant
const RENDER_SERVER_URL = "https://mini-royale-backend-4rrg.onrender.com"; 

// Line 972: FIX: MUST be 'let' and initialized to null.
// This resolves the 'Assignment to constant variable' error at line 2375.
let socket = null; 

// DELETE everything from line 976 downwards (socket.on('disconnect', ...)) 
// until the next function definition. The listeners must live in initMultiplayer().

    const poolGrid=document.getElementById('poolGrid');
    const deckSlotsEl=document.getElementById('deckSlots');
    const deckPreview=document.getElementById('deckPreview');
    const goldDisplay = document.getElementById('goldDisplay');
    const gemsDisplay = document.getElementById('gemsDisplay');
    const trophyDisplay = document.getElementById('trophyDisplay');
    const cardsPoolEl = document.getElementById('cardsPool');
    const deckEditorEl = document.getElementById('deckEditor');
    const shopViewEl = document.getElementById('shopView');
    const gameBoardEl = document.getElementById('gameBoard');
    const userNameDisplay = document.getElementById('userNameDisplay');
    const arenaEl = document.getElementById('arena');
    const unitContainerEl = document.getElementById('unitContainer'); 
    const placementLineEl = document.getElementById('placementLine');
    const elixirCounterEl = document.getElementById('elixirCounter');
    const elixirFillEl = document.getElementById('elixirFill');
    const statusMessageEl = document.getElementById('statusMessage');
    const updateLogModalEl = document.getElementById('updateLogModal');
    const arenasModalEl = document.getElementById('arenasModal');
    const forfeitBtnEl = document.getElementById('forfeitBtn');
    
    // Sound Elements
    const clickSound = document.getElementById('clickSound');
    const gameStartSound = document.getElementById('gameStartSound');
    const towerAttackSound = document.getElementById('towerAttackSound');
    
    document.querySelectorAll('.menu button').forEach(button => {
        button.addEventListener('click', () => {
            clickSound.currentTime = 0;
            clickSound.play().catch(e => console.log("Sound play prevented: ", e));
        });
    });
    
    // --- UTILITY ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    /** Generates a unique ID for the player. */
    function generatePlayerID() {
        return 'MR-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5).toUpperCase();
    }
    
    /** Gets a random emoji from the new PROFILE_EMOJIS list for a profile picture. */
    function generateRandomProfileEmoji() {
        const index = Math.floor(Math.random() * PROFILE_EMOJIS.length);
        return PROFILE_EMOJIS[index];
    }
    
    /** Helper to get tag data by name */
    function getTagByName(tagName) {
        if (tagName === TAG_NONE.name) return TAG_NONE;
        if (tagName === CREATOR_TAG.name) return CREATOR_TAG;
        return TAG_RARITIES.find(tag => tag.name === tagName);
    }


    // --- GAME STATE ---
    let currentDeck=Array(8).fill(null);
    let gold = 1000;
    let gems = 50;
    let unlockedCards = CARD_TEMPLATES.map((_, i) => i < 12);
    let userName = ''; 
    let trophies = 0; 
    let isInMatch = false;
    let isConnecting = false;
    let gameEnded = false;
    let selectedCardId = null; 

    // *** NEW: Friends System Mocks ***
    let MOCK_FRIENDS_POOL = []; // A list of all searchable players (including the user)
    let selectedChatFriendId = null; 

    // Global State for Profile/Stats/Tags/Friends
    let globalState = {
        maxTrophies: 0,
        wins: 0,
        losses: 0,
        forfeits: 0,
        playerID: '',
        profilePic: 'üë§',
        idChangeUsed: false,
        unlockedTags: [TAG_NONE.name], 
        equippedTag: TAG_NONE.name,
        // Friends System State
        friendsList: [], // Array of { id, username, profilePic, trophies, status: 'online'|'offline' }
        blockedList: [], // Array of { id, username }
        mockMessages: {} // Keyed by friendId, stores [{ senderId, message, timestamp }]
    };

    // Tower configuration with combat stats
    const towerConfig = {
        king: { health: 3000, maxHealth: 3000, active: false, emoji: 'üëë', damage: KING_TOWER_DAMAGE, range: TOWER_RANGE, attackRate: KING_ATTACK_RATE, attackTimer: 0 },
        princessL: { health: 1800, maxHealth: 1800, emoji: 'üè∞', damage: PRINCESS_TOWER_DAMAGE, range: TOWER_RANGE, attackRate: PRINCESS_ATTACK_RATE, attackTimer: 0 },
        princessR: { health: 1800, maxHealth: 1800, emoji: 'üè∞', damage: PRINCESS_TOWER_DAMAGE, range: TOWER_RANGE, attackRate: PRINCESS_ATTACK_RATE, attackTimer: 0 }
    };

    let gameState = {
        timer: 180,
        elixir: 5.0,
        maxElixir: 10,
        towers: {
            player: JSON.parse(JSON.stringify(towerConfig)), 
            opponent: JSON.parse(JSON.stringify(towerConfig)) 
        },
        playerHand: [],
        drawPile: [], 
        discardPile: [], 
        placementBoundary: 0.5,
        placedUnits: []
    };
    
    let gameClockInterval = null;
    let elixirInterval = null;
    let gameLogicInterval = null;

    // --- LOCAL STORAGE DATA STORE ---
    function generateRandomName() {
        const randomIndex = Math.floor(Math.random() * FUNNY_NAMES.length);
        // Only use the name part, not the emoji
        return FUNNY_NAMES[randomIndex].replace(/\p{Emoji}/u, '').trim();
    }

    function loadGameData() {
        try {
            const savedData = localStorage.getItem('miniRoyaleData');
            if (savedData) {
                const data = JSON.parse(savedData);
                currentDeck = data.currentDeck || Array(8).fill(null);
                gold = data.gold || 1000;
                gems = data.gems || 50;
                unlockedCards = data.unlockedCards || CARD_TEMPLATES.map((_, i) => i < 12);
                userName = data.userName || generateRandomName(); 
                trophies = data.trophies || 0; 

                // Load Global State
                globalState.maxTrophies = data.maxTrophies || 0; 
                globalState.wins = data.wins || 0;              
                globalState.losses = data.losses || 0;          
                globalState.forfeits = data.forfeits || 0;     
                globalState.playerID = data.playerID || generatePlayerID(); 
                globalState.profilePic = data.profilePic || generateRandomProfileEmoji(); 
                globalState.idChangeUsed = data.idChangeUsed || false; 
                globalState.unlockedTags = data.unlockedTags || [TAG_NONE.name];
                globalState.equippedTag = data.equippedTag || TAG_NONE.name;
                
                // NEW: Load Friends Data
                globalState.friendsList = data.friendsList || [];
                globalState.blockedList = data.blockedList || [];
                globalState.mockMessages = data.mockMessages || {};

            } else {
                // First time setup
                userName = generateRandomName();
                globalState.playerID = generatePlayerID();
                globalState.profilePic = generateRandomProfileEmoji();
                globalState.idChangeUsed = false;
                globalState.unlockedTags = [TAG_NONE.name]; 
                globalState.equippedTag = TAG_NONE.name;
                globalState.friendsList = [];
                globalState.blockedList = [];
                globalState.mockMessages = {};
                saveGameData(); 
            }
            
            // ADD CREATOR TAG FOR THE USER
            if (!globalState.unlockedTags.includes(CREATOR_TAG.name)) {
                globalState.unlockedTags.push(CREATOR_TAG.name);
            }
            // Ensure equipped tag is still valid
            if (!globalState.unlockedTags.includes(globalState.equippedTag)) {
                globalState.equippedTag = TAG_NONE.name;
            }

            // NEW: Generate mock players after loading current user data

            updateTrophyUnlocks();
            enforceArenaDeckRules(); 

        } catch (e) {
            console.error("Error loading game data:", e);
        }
    }

    function saveGameData() {
        try {
            const dataToSave = {
                currentDeck,
                gold,
                gems,
                unlockedCards,
                userName,
                trophies,
                // Global State
                maxTrophies: globalState.maxTrophies,
                wins: globalState.wins,
                losses: globalState.losses,
                forfeits: globalState.forfeits,
                playerID: globalState.playerID,
                profilePic: globalState.profilePic,
                idChangeUsed: globalState.idChangeUsed,
                unlockedTags: globalState.unlockedTags,
                equippedTag: globalState.equippedTag,
                // Friends Data
                friendsList: globalState.friendsList,
                blockedList: globalState.blockedList,
                mockMessages: globalState.mockMessages
            };
            localStorage.setItem('miniRoyaleData', JSON.stringify(dataToSave));
        } catch (e) {
            console.error("Error saving game data:", e);
        }
    }
    
    // --- FRIENDS SYSTEM LOGIC ---

 // PASTE THE CORRECTED searchUsers FUNCTION HERE:
function searchUsers(query) {
    if (!query) return;

    // Use the live Render URL and the /api/users/search endpoint
    fetch(`${RENDER_SERVER_URL}/api/users/search?q=${query}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Server responded with status: ${response.status}`);
            }
            return response.json();
        })
        .then(results => {
            console.log('Search Results from Server:', results);

            // Render the results (existing logic to display the 'results' array)
            const resultsList = document.getElementById('searchResultsList');
            resultsList.innerHTML = '';

            if (results.length === 0) {
                resultsList.innerHTML = '<p style="color:var(--muted);">No users found.</p>';
                return;
            }

            results.forEach(user => {
                const el = document.createElement('div');
                el.className = 'friend-list-item';
                el.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="font-size: 24px;">${user.profilePic || 'üë§'}</div>
                        <strong>${user.username}</strong>
                        <p style="margin: 0; color: var(--muted); font-size: 0.9em;">ID: ${user.id}</p>
                    </div>
                    <button onclick="sendFriendRequest('${user.id}')" style="background: var(--accent); color: var(--bg-1); border: none; padding: 5px 10px; border-radius: 6px; cursor: pointer;">Add</button>
                `;
                resultsList.appendChild(el);
            });
        })
        .catch(error => {
            console.error('Error during user search:', error);
            const resultsList = document.getElementById('searchResultsList');
            resultsList.innerHTML = `<p style="color:red;">Error connecting to server: ${error.message}</p>`;
        });
} // <--- Make sure this is the only brace closing the function
  // and that no extra braces follow it before the next function definition.

// --- FRIENDS SYSTEM FUNCTIONS (LINES 1251 onwards) ---

function findMockUser(query) {
¬† ¬† ¬† ¬† if (!query) return null;
¬† ¬† ¬† ¬† const lowerQuery = query.toLowerCase().trim();
¬† ¬† ¬† ¬† return MOCK_FRIENDS_POOL.find(user =>¬†
¬† ¬† ¬† ¬† ¬† ¬† user.id.toLowerCase() === lowerQuery ||¬†
¬† ¬† ¬† ¬† ¬† ¬† user.username.toLowerCase() === lowerQuery
¬† ¬† ¬† ¬† );
¬† ¬† } // <--- üí• ADD THIS CLOSING BRACE HERE!

    function addFriendFromInput() {
    const friendInput = document.getElementById('friendInput');
    const targetIdOrUsername = friendInput.value.trim();

    if (!targetIdOrUsername) {
        alert('Please enter a username or ID.');
        return;
    }

    // CRITICAL: Checks for the active connection before sending the request
    if (!socket || !socket.connected) {
        alert('Cannot send request: You must be connected to the multiplayer server. Try starting a game first.');
        return;
    }
    
    // 1. Emit the request to the server to handle the friend request
    socket.emit('sendFriendRequest', { 
        targetIdOrUsername: targetIdOrUsername,
        senderId: globalState.playerID 
    });

    // 2. Clear input and give immediate feedback
    friendInput.value = '';
    alert(`Friend request sent to ${targetIdOrUsername}. Awaiting server confirmation!`);
}

function setupFriendRequestListeners() {
    if (socket) {
        // 1. SUCCESS Listener: The server confirms the friend was added
        socket.on('friendRequestAccepted', (newFriendData) => {
            if (!globalState.friendsList.some(f => f.id === newFriendData.id)) {
                globalState.friendsList.push(newFriendData);
                saveGameData();
                renderFriendsList();
                renderChatSidebar();
                alert(`üéâ ${newFriendData.username} accepted your friend request!`);
            }
        });

        // 2. FAILURE Listener: The server reports an error (e.g., user not found)
        socket.on('friendRequestFailed', (message) => {
            alert(`Friend Request Failed: ${message}`);
        });
    }
}

    function unfriend(friendId) {
        if (confirm("Are you sure you want to remove this player?")) {
            globalState.friendsList = globalState.friendsList.filter(f => f.id !== friendId);
            // Also remove chat history
            delete globalState.mockMessages[friendId];
            saveGameData();
            renderFriendsList();
            if (selectedChatFriendId === friendId) {
                selectedChatFriendId = null;
                renderChat(); 
            }
            alert("Player removed from friends list.");
        }
    }
    
    function blockPlayer(friendId, friendName) {
        if (confirm(`Are you sure you want to block ${friendName}? This will also unfriend them.`)) {
            // Unfriend first
            globalState.friendsList = globalState.friendsList.filter(f => f.id !== friendId);
            // Block
            const userToBlock = findMockUser(friendId) || { id: friendId, username: friendName };
            if (!globalState.blockedList.some(b => b.id === friendId)) {
                globalState.blockedList.push({ id: userToBlock.id, username: userToBlock.username });
            }
            saveGameData();
            renderFriendsList();
            renderBlockedList();
            alert(`${friendName} has been blocked.`);
        }
    }

    function unblockPlayer(friendId) {
         if (confirm("Are you sure you want to unblock this player?")) {
            globalState.blockedList = globalState.blockedList.filter(b => b.id !== friendId);
            saveGameData();
            renderBlockedList();
            alert("Player unblocked.");
        }
    }
    
    function startMock1v1(friendId, friendName) {
        if (isInMatch) {
            alert("You are already in a match!");
            return;
        }

        if (currentDeck.filter(Boolean).length !== 8) {
            alert("Your deck must have exactly 8 cards to challenge!");
            return;
        }

        if (confirm(`Are you sure you want to challenge ${friendName} to a 1v1? (This will start a mock game.)`)) {
            document.getElementById('friendsModal').style.display = 'none';
            changeView('game');
            displayStatusMessage(`Challenging ${friendName}... Match Started!`, 3000);
        }
    }

    // --- CURRENCY GIFTING ---
    function giftCurrencyWrapper(type) {
        const amountEl = document.getElementById(type === 'gold' ? 'giftGoldAmount' : 'giftGemAmount');
        const amount = parseInt(amountEl.value);

        if (!selectedChatFriendId) {
            alert('Please select a friend in the chat sidebar first!');
            return;
        }

        if (isNaN(amount) || amount <= 0) {
            alert('Please enter a valid amount greater than 0.');
            return;
        }
        
        const friend = globalState.friendsList.find(f => f.id === selectedChatFriendId);
        if (!friend) return; // Should not happen if selectedChatFriendId is set

        if (type === 'gold') {
            if (amount > MAX_GIFT_GOLD) {
                 alert(`Cannot gift more than üí∞ ${MAX_GIFT_GOLD} Gold.`);
                 return;
            }
            if (gold < amount) {
                alert(`You only have üí∞ ${gold} Gold! Not enough.`);
                return;
            }
            
            gold -= amount;
            // Mock gift to friend
            sendMessage(null, `üéÅ I sent you üí∞ ${amount} Gold!`);
            alert(`You gifted üí∞ ${amount} Gold to ${friend.username}!`);

        } else if (type === 'gems') {
            if (amount > MAX_GIFT_GEMS) {
                alert(`Cannot gift more than üíé ${MAX_GIFT_GEMS} Gems.`);
                return;
            }
            if (gems < amount) {
                alert(`You only have üíé ${gems} Gems! Not enough.`);
                return;
            }

            gems -= amount;
            // Mock gift to friend
            sendMessage(null, `üéÅ I sent you üíé ${amount} Gems!`);
            alert(`You gifted üíé ${amount} Gems to ${friend.username}!`);
        }

        amountEl.value = '';
        saveGameData();
        updateAll(); 
    }

    // --- CHAT LOGIC ---
    function selectChatFriend(friendId) {
        selectedChatFriendId = friendId;
        renderChat();
    }

    function sendMessage(message = null, overrideText = null) {
        const friendId = selectedChatFriendId;
        if (!friendId) {
            alert('Select a friend to message!');
            return;
        }

        const chatInput = document.getElementById('chatInput');
        let text = overrideText || chatInput.value.trim();

        if (text === '') return;

        if (!globalState.mockMessages[friendId]) {
            globalState.mockMessages[friendId] = [];
        }

        globalState.mockMessages[friendId].push({
            senderId: globalState.playerID,
            message: text,
            timestamp: new Date().toLocaleTimeString()
        });

        chatInput.value = '';
        saveGameData();
        renderChatMessages(); 
        
        // Mock reply from friend after a delay
        if (!overrideText) {
             setTimeout(() => {
                const friend = globalState.friendsList.find(f => f.id === friendId);
                const reply = ['Cool!', 'Awesome.', 'Sounds good!', 'üëç'].sort(() => 0.5 - Math.random())[0];
                globalState.mockMessages[friendId].push({
                    senderId: friendId,
                    message: reply,
                    timestamp: new Date().toLocaleTimeString()
                });
                saveGameData();
                renderChatMessages(); 
            }, 1000);
        }
    }
    
    // --- RENDER FUNCTIONS FOR MODALS ---

    function renderFriendsList() {
        const container = document.getElementById('friendListContainer');
        const countDisplay = document.getElementById('friendCountDisplay');
        container.innerHTML = '';
        
        if (globalState.friendsList.length === 0) {
            container.innerHTML = '<p style="color: var(--muted);">You have no friends. Go add some!</p>';
            countDisplay.textContent = 'Friends: 0';
            return;
        }
        
        countDisplay.textContent = `Friends: ${globalState.friendsList.length}`;

        globalState.friendsList.forEach(friend => {
            const el = document.createElement('div');
            el.className = 'friend-list-item';
            el.innerHTML = `
                <div class="friend-info">
                    <div style="font-size: 24px;">${friend.profilePic || 'üë§'}</div>
                    <div>
                        <strong style="font-size: 1.1em;">${friend.username}</strong> 
                        <span style="color: var(--trophy-color); margin-left: 8px;">üèÜ ${friend.trophies}</span>
                        <p style="margin: 0; font-size: 0.8em; color: ${friend.status === 'online' ? 'limegreen' : 'red'};">${friend.status === 'online' ? '‚óè Online' : '‚óã Offline'}</p>
                    </div>
                </div>
                <div class="friend-actions">
                    <button style="background: var(--accent);" onclick="startMock1v1('${friend.id}', '${friend.username}')">1v1</button>
                    <button style="background: #2196f3; color: white;" onclick="switchFriendsTab('chat'); selectChatFriend('${friend.id}')">Chat</button>
                    <button style="background: #e74c3c; color: white;" onclick="unfriend('${friend.id}')">Unfriend</button>
                    <button style="background: #7f8c8d; color: white;" onclick="blockPlayer('${friend.id}', '${friend.username}')">Block</button>
                </div>
            `;
            container.appendChild(el);
        });
    }

    function renderBlockedList() {
        const container = document.getElementById('blockedListContainer');
        container.innerHTML = '';

        if (globalState.blockedList.length === 0) {
            container.innerHTML = '<p style="color: var(--muted);">No players are currently blocked.</p>';
            return;
        }

        globalState.blockedList.forEach(blocked => {
            const el = document.createElement('div');
            el.className = 'friend-list-item';
            el.innerHTML = `
                <div class="friend-info">
                    <div style="font-size: 24px;">‚õî</div>
                    <div>
                        <strong style="font-size: 1.1em;">${blocked.username}</strong>
                        <p style="margin: 0; font-size: 0.8em; color: #e74c3c;">BLOCKED</p>
                    </div>
                </div>
                <div class="friend-actions">
                    <button style="background: #2ecc71; color: white;" onclick="unblockPlayer('${blocked.id}')">Unblock</button>
                </div>
            `;
            container.appendChild(el);
        });
    }

    function renderChatSidebar() {
        const sidebar = document.getElementById('chatSidebar');
        sidebar.innerHTML = '';

        globalState.friendsList.forEach(friend => {
            const el = document.createElement('div');
            el.className = `chat-list-item ${friend.id === selectedChatFriendId ? 'active' : ''}`;
            el.onclick = () => selectChatFriend(friend.id);
            el.innerHTML = `
                <div style="font-size: 20px; float: left; margin-right: 8px;">${friend.profilePic || 'üë§'}</div>
                <strong>${friend.username}</strong>
                <p style="margin: 0; font-size: 0.8em; color: ${friend.status === 'online' ? 'limegreen' : 'red'};">${friend.status === 'online' ? '‚óè Online' : '‚óã Offline'}</p>
            `;
            sidebar.appendChild(el);
        });

        if (globalState.friendsList.length === 0) {
            sidebar.innerHTML = '<p style="padding: 10px; color: var(--muted);">Add friends to chat.</p>';
        }
    }

    function renderChatMessages() {
        const messagesArea = document.getElementById('chatMessages');
        messagesArea.innerHTML = '';
        
        const chatInputEl = document.getElementById('chatInput');
        const sendBtnEl = document.getElementById('sendMsgBtn');
        const chatHeader = document.getElementById('chatHeader');

        if (!selectedChatFriendId) {
            chatHeader.textContent = 'Select a Friend to Chat';
            chatInputEl.disabled = true;
            sendBtnEl.disabled = true;
            messagesArea.innerHTML = '<p style="color: var(--muted); text-align: center; margin-top: 50px;">No conversation selected.</p>';
            return;
        }

        const friend = globalState.friendsList.find(f => f.id === selectedChatFriendId);
        
        chatHeader.textContent = `Chat with ${friend.username}`;
        chatInputEl.disabled = false;
        sendBtnEl.disabled = false;
        
        const messages = globalState.mockMessages[selectedChatFriendId] || [];

        messages.forEach(msg => {
            const isYou = msg.senderId === globalState.playerID;
            const el = document.createElement('div');
            el.className = `message-bubble message-${isYou ? 'you' : 'friend'}`;
            el.innerHTML = `
                ${msg.message}
                <span style="font-size: 0.7em; opacity: 0.7; display: block; text-align: ${isYou ? 'right' : 'left'};">${msg.timestamp}</span>
            `;
            messagesArea.appendChild(el);
        });

        // Scroll to bottom
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    function renderEmojiPicker() {
        const picker = document.getElementById('emojiPicker');
        picker.innerHTML = '';

        MESSAGE_EMOJIS.forEach(emoji => {
            const btn = document.createElement('button');
            btn.textContent = emoji;
            btn.onclick = () => sendMessage(null, emoji);
            picker.appendChild(btn);
        });
    }

    function renderChat() {
        renderChatSidebar();
        renderChatMessages();
        renderEmojiPicker(); 
    }

    function switchFriendsTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(el => el.style.display = 'none');
        document.querySelectorAll('.friend-tabs button').forEach(el => el.classList.remove('active'));

        document.getElementById(`${tabName}Content`).style.display = 'block';
        document.getElementById(`tab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).classList.add('active');

        if (tabName === 'friendsList') {
            renderFriendsList();
        } else if (tabName === 'addBlock') {
            renderBlockedList();
        } else if (tabName === 'chat') {
            renderChat();
        }
    }

    function showFriendsModal() {
        if (isInMatch || isConnecting || gameEnded) {
            alert("Please wait for the current match state to resolve before managing friends.");
            return;
        }
        // Always open to the Friends List tab first
        switchFriendsTab('friendsList'); 
        document.getElementById('friendsModal').style.display = 'flex';
    }


    // --- VIEW MANAGEMENT & OTHER EXISTING FUNCTIONS (Updated) ---

    function getCurrentArena() {
        return ARENAS.slice().reverse().find(arena => trophies >= arena.minTrophies) || ARENAS[0];
    }
    
    function getCardUnlockInfo(cardId) {
        if (cardId <= 12) return { arenaId: 0, minTrophies: 0 };
        for (const arena of ARENAS) {
            if (arena.unlockCardIds.includes(cardId)) {
                return { arenaId: arena.id, minTrophies: arena.minTrophies };
            }
        }
        return { arenaId: Infinity, minTrophies: Infinity };
    }

    function updateTrophyUnlocks() {
        ARENAS.forEach(arena => {
            if (trophies >= arena.minTrophies) {
                arena.unlockCardIds.forEach(cardId => {
                    unlockedCards[cardId - 1] = true;
                });
            }
        });
    }

    function enforceArenaDeckRules() {
        let refundTotalGold = 0;
        let removedCards = [];
        const playerCurrentArenaId = getCurrentArena().id; 

        currentDeck.forEach((cardId, index) => {
            if (cardId !== null) {
                const card = CARD_TEMPLATES.find(c => c.id === cardId);
                if (!card) return;

                const cardUnlockArenaId = CARD_UNLOCK_MAP[cardId];
                
                if (cardUnlockArenaId > playerCurrentArenaId) {
                    removedCards.push(card.name);
                    currentDeck[index] = null;
                    
                    const goldRefund = card.cost * REFUND_GOLD_PER_ELIXIR; 
                    refundTotalGold += goldRefund;
                }
            }
        });

        if (removedCards.length > 0) {
            gold += refundTotalGold;
            
            let message = `**Deck Cards Removed!**\n`;
            message += `You were using cards from higher arenas, which have been removed:\n`;
            message += removedCards.join(', ');
            message += `\n\n**Refund:** üí∞ ${refundTotalGold} Gold.`;
            
            alert(message);
            saveGameData();
        }
    }


    // --- UTILITIES ---
    function distance(p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }
    
    function getTowerPosition(player, key) {
        const arenaRect = arenaEl.getBoundingClientRect();
        const arenaHeight = arenaRect.height;
        const arenaWidth = arenaRect.width;

        const towerHeight = (key === 'king') ? 100 : 80;
        const towerBottomMargin = 10;
        const towerCenterY = towerBottomMargin + (towerHeight / 2);
        
        if (player === 'player') {
            if (key === 'king') return { x: arenaWidth * 0.5, y: arenaHeight - towerCenterY };
            if (key === 'princessL') return { x: arenaWidth * 0.25, y: arenaHeight - towerCenterY + 10}; 
            if (key === 'princessR') return { x: arenaWidth * 0.75, y: arenaHeight - towerCenterY + 10};
        } else { // opponent
            if (key === 'king') return { x: arenaWidth * 0.5, y: towerCenterY };
            if (key === 'princessL') return { x: arenaWidth * 0.25, y: towerCenterY - 10 };
            if (key === 'princessR') return { x: arenaWidth * 0.75, y: towerCenterY - 10 };
        }
        return { x: 0, y: 0 };
    }
    
    function displayStatusMessage(message, duration = 2000) {
        statusMessageEl.textContent = message;
        statusMessageEl.style.opacity = 1;
        
        setTimeout(() => {
            statusMessageEl.style.opacity = 0;
            setTimeout(() => statusMessageEl.textContent = '', 2000); 
        }, duration);
    }
    
    function handleForfeit() {
        if (!isInMatch || gameEnded) return;

        if (confirm("Are you sure you want to forfeit? Quitting is a loser's move, you will lose 50 Trophies!")) {
            endGame('forfeit');
        }
    }

    function endGame(result) {
        if (gameEnded) return;

        gameEnded = true;
        clearInterval(gameClockInterval);
        clearInterval(elixirInterval);
        clearInterval(gameLogicInterval);
        forfeitBtnEl.style.display = 'none'; 

        let message = '';
        let trophyChange = 0;

        if (result === 'victory') {
            trophyChange = TROPHY_WIN;
            message = `VICTORY! You gained ${trophyChange} Trophies! üéâ`;
            globalState.wins++; 
            arenaEl.style.boxShadow = '0 0 50px rgba(110, 231, 183, 1)';
        } else if (result === 'defeat' || result === 'draw') {
            trophyChange = TROPHY_LOSS;
            message = `DEFEAT! You lost ${Math.abs(trophyChange)} Trophies. üòî`;
            globalState.losses++; 
            arenaEl.style.boxShadow = '0 0 50px rgba(255, 0, 0, 1)';
        } else if (result === 'forfeit') {
            trophyChange = TROPHY_FORFEIT_LOSS;
            message = `FORFEIT! You lost ${Math.abs(trophyChange)} Trophies. Quitting is a loser! üòí`;
            globalState.forfeits++; 
            arenaEl.style.boxShadow = '0 0 50px rgba(255, 165, 0, 1)';
        }
        
        // Update Trophies
        trophies = Math.max(0, trophies + trophyChange);
        globalState.maxTrophies = Math.max(globalState.maxTrophies, trophies); 
        saveGameData();
        updateTrophyUnlocks();

        renderArena(message);
        
        // Return to lobby after a delay
        setTimeout(() => {
            isInMatch = false; 
            gameEnded = false;
            updateButtonStates();
            changeView('deck');
            arenaEl.style.boxShadow = '0 10px 40px rgba(0,0,0,0.6)'; // Reset shadow
            updateAll(); // Update trophy display
        }, 8000);
    }

    function checkWinCondition() {
        const playerTowers = Object.values(gameState.towers.player).filter(t => t.health > 0).length;
        const opponentTowers = Object.values(gameState.towers.opponent).filter(t => t.health > 0).length;

        if (playerTowers === 0) {
            endGame('defeat');
            return true;
        }
        if (opponentTowers === 0) {
            endGame('victory');
            return true;
        }
        return false;
    }


    // --- GAME LOGIC SIMULATION (MOCK) ---
    function towerCombat(owner) {
        const towers = gameState.towers[owner];
        const opponentUnits = gameState.placedUnits.filter(u => u.owner !== owner && u.card.type === 'troop' && u.hp > 0);

        for (const key in towers) {
            const tower = towers[key];
            if (tower.health <= 0) continue; 

            if (key === 'king' && !tower.active) {
                if (towers.princessL.health <= 0 || towers.princessR.health <= 0) {
                    tower.active = true;
                } else {
                    continue; 
                }
            }

            tower.attackTimer = (tower.attackTimer || 0) + 1;

            if (tower.attackTimer % tower.attackRate === 0) {
                const towerPos = getTowerPosition(owner, key);
                
                let closestTarget = null;
                let minDistance = Infinity;

                opponentUnits.forEach(unit => {
                    const dist = distance(towerPos, unit.position);
                    if (dist < minDistance && dist <= tower.range) {
                        minDistance = dist;
                        closestTarget = unit;
                    }
                });

                if (closestTarget) {
                    closestTarget.hp = Math.max(0, closestTarget.hp - tower.damage);
                    
                    createProjectile(towerPos, closestTarget.position, key === 'king' ? 'cannon' : 'arrow');
                    
                    towerAttackSound.currentTime = 0;
                    towerAttackSound.play().catch(e => console.log("Sound play prevented: ", e));
                }
            }
        }
    }

    function updateGameLogic() {
        if (gameEnded) return;

        towerCombat('player');
        towerCombat('opponent');

        gameState.placedUnits.filter(u => u.card.type === 'troop' && u.hp > 0).forEach(unit => {
            const owner = unit.owner;
            const enemyOwner = owner === 'player' ? 'opponent' : 'player';

            const enemyUnits = gameState.placedUnits.filter(u => u.owner === enemyOwner && u.card.type === 'troop' && u.hp > 0);
            
            const enemyTowers = Object.entries(gameState.towers[enemyOwner])
                .map(([key, data]) => ({ 
                    key: key,
                    data: data,
                    position: getTowerPosition(enemyOwner, key),
                    type: 'tower',
                    isKing: key === 'king'
                }))
                .filter(t => t.data.health > 0);

            const princessTowersAlive = enemyTowers.filter(t => !t.isKing).length > 0;
            const kingTower = enemyTowers.find(t => t.isKing);

            let potentialTargets = [...enemyUnits, ...enemyTowers.filter(t => !t.isKing)];
            
            if (!princessTowersAlive && kingTower) {
                potentialTargets.push(kingTower);
            }

            let closestTarget = null;
            let minDistance = Infinity;

            potentialTargets.forEach(target => {
                const targetPos = target.position; 
                const dist = distance(unit.position, targetPos);
                
                if (dist < minDistance) {
                    minDistance = dist;
                    closestTarget = target;
                }
            });

            unit.target = closestTarget;
            unit.isAttacking = false;

            if (closestTarget) {
                if (minDistance <= unit.card.range) {
                    unit.isAttacking = true;
                    const attackRate = unit.card.attackRate || 60; 
                    
                    if ((unit.attackTimer || 0) % attackRate === 0) { 
                        const damage = unit.card.damage;
                        
                        if (closestTarget.type === 'tower') {
                            closestTarget.data.health = Math.max(0, closestTarget.data.health - damage);
                            updatePlacementBoundary(); 
                        } else {
                            closestTarget.hp = Math.max(0, closestTarget.hp - damage);
                        }
                    }
                    unit.attackTimer = (unit.attackTimer || 0) + 1;

                } else {
                    const dx = closestTarget.position.x - unit.position.x;
                    const dy = closestTarget.position.y - unit.position.y;
                    const angle = Math.atan2(dy, dx);
                    
                    const moveDist = unit.card.speed * 1.0; 
                    unit.position.x += Math.cos(angle) * moveDist;
                    unit.position.y += Math.sin(angle) * moveDist;
                }
            }
        });
        
        gameState.placedUnits = gameState.placedUnits.filter(u => u.hp > 0);
        
        checkWinCondition();
        
        renderArena(); 
    }

    function createProjectile(startPos, endPos, type) {
        const projectileEl = document.createElement('div');
        projectileEl.className = `projectile ${type === 'cannon' ? 'cannon' : ''}`;
        
        projectileEl.style.left = `${startPos.x}px`;
        projectileEl.style.top = `${startPos.y}px`;
        projectileEl.style.transform = 'translate(-50%, -50%)'; 

        unitContainerEl.appendChild(projectileEl);

        const travelDist = distance(startPos, endPos);
        const duration = Math.min(0.5, travelDist / 800); 

        projectileEl.style.transition = `left ${duration}s linear, top ${duration}s linear`;

        setTimeout(() => {
            projectileEl.style.left = `${endPos.x}px`;
            projectileEl.style.top = `${endPos.y}px`;
        }, 10);

        setTimeout(() => {
            projectileEl.remove();
        }, duration * 1000 + 50); 
    }

    function mockOpponentPlacement(playerX, playerY) {
        if (Math.random() < 0.5) {
            const availableTroops = CARD_TEMPLATES.filter(c => c.type === 'troop');
            const randomCard = availableTroops[Math.floor(Math.random() * availableTroops.length)];
            
            const unitsToSpawn = randomCard.unitCount;

            const arenaHeight = arenaEl.clientHeight;
            const mockYMin = arenaHeight * 0.1; 
            const mockYMax = arenaHeight * 0.5;
            
            let mockY = Math.min(mockYMax - 30, Math.max(mockYMin, playerY - arenaHeight * 0.3 + Math.random() * arenaHeight * 0.2));
            const mockX = playerX + Math.random() * 100 - 50;


            for (let i = 0; i < unitsToSpawn; i++) {
                let posX = mockX;
                let posY = mockY;
                
                if (unitsToSpawn > 1) {
                    posX += (Math.random() - 0.5) * 40; 
                    posY += (Math.random() - 0.5) * 40;
                }
                
                gameState.placedUnits.push({
                    id: Date.now() + Math.random() + i,
                    card: randomCard,
                    hp: randomCard.unitHp, 
                    position: { x: posX, y: posY }, 
                    owner: 'opponent',
                    attackTimer: 0
                });
            }
        }
    }
    
    function updatePlacementBoundary() {
        const opponentPLoss = gameState.towers.opponent.princessL.health <= 0;
        const opponentRLoss = gameState.towers.opponent.princessR.health <= 0;
        
        if (opponentPLoss && opponentRLoss) {
            gameState.placementBoundary = 0.175; 
            gameState.towers.opponent.king.active = true;
            placementLineEl.style.background = 'rgba(255, 69, 0, 0.7)'; 
        } else if (opponentPLoss || opponentRLoss) {
            gameState.placementBoundary = 0.35; 
            gameState.towers.opponent.king.active = true; 
            placementLineEl.style.background = 'rgba(255, 165, 0, 0.7)'; 
        } else {
            gameState.placementBoundary = 0.5;
            placementLineEl.style.background = 'var(--placement-line-color)'; 
        }

        if (gameState.towers.player.princessL.health <= 0 || gameState.towers.player.princessR.health <= 0) {
            gameState.towers.player.king.active = true;
        }
    }


    // --- VIEW MANAGEMENT ---
    let currentView = 'deck'; 
    
    function updateButtonStates() {
        const shopBtn = document.getElementById('shopBtn');
        const deckEditorBtn = document.getElementById('deckEditorBtn');
        const playBtn = document.getElementById('playBtn');
        const arenasBtn = document.getElementById('arenasBtn');
        const profileBtn = document.getElementById('profileBtn'); 
        const settingsBtn = document.getElementById('settingsBtn'); 
        const friendsBtn = document.getElementById('friendsBtn'); 
        
        const isGameActive = isInMatch || isConnecting || gameEnded;
        
        // Hide/Show Forfeit button
        forfeitBtnEl.style.display = isInMatch ? 'inline-block' : 'none';

        shopBtn.disabled = isGameActive;
        deckEditorBtn.disabled = isGameActive;
        arenasBtn.disabled = isGameActive;
        profileBtn.disabled = isGameActive; 
        settingsBtn.disabled = isGameActive; 
        friendsBtn.disabled = isGameActive;
        
        if (isConnecting) {
            playBtn.textContent = "Connecting...";
            playBtn.disabled = true;
        } else if (isInMatch || gameEnded) {
            playBtn.textContent = "Game In Progress";
            playBtn.disabled = true;
        } else {
            const currentArena = getCurrentArena();
            playBtn.innerHTML = `‚ñ∂ Play Game <span style="font-size: 0.8em; color: ${currentArena.minTrophies > 0 ? 'var(--trophy-color)' : 'var(--accent)'};">(${currentArena.name})</span>`;
            playBtn.disabled = false;
        }
    }
    
    // Helper to update username display with tag
    function updateUserNameDisplay(view) {
        const equippedTag = getTagByName(globalState.equippedTag);
        const tagHtml = equippedTag.name !== TAG_NONE.name ? 
            `<span style="color: ${equippedTag.color}; font-size: 0.9em; margin-left: 8px;">${equippedTag.emoji}[${equippedTag.name}]</span>` : '';

        const viewTitle = view === 'game' ? ' - Arena' : ` - ${view.charAt(0).toUpperCase() + view.slice(1)}`;
        
        document.getElementById('userNameDisplay').innerHTML = `${globalState.profilePic} ${userName}${tagHtml}${viewTitle}`;
    }


    function changeView(view){
        if ((isInMatch || isConnecting || gameEnded) && view !== 'game') {
            alert("Please wait for the current match state to resolve.");
            return;
        }

        currentView = view;
        cardsPoolEl.style.display = 'none';
        deckEditorEl.style.display = 'none';
        shopViewEl.style.display = 'none';
        gameBoardEl.style.display = 'none';
        arenaEl.classList.remove('drag-over-valid', 'drag-over-invalid'); 
        document.getElementById('updateLogModal').style.display = 'none'; 
        document.getElementById('arenasModal').style.display = 'none'; 
        document.getElementById('profileModal').style.display = 'none';
        document.getElementById('settingsModal').style.display = 'none'; 
        document.getElementById('friendsModal').style.display = 'none'; // Close friends modal

        clearInterval(gameClockInterval);
        clearInterval(elixirInterval);
        clearInterval(gameLogicInterval);
        
        if(view === 'deck'){
            cardsPoolEl.style.display = 'flex';
            deckEditorEl.style.display = 'flex';
            
            if(socket) socket.disconnect();
            isInMatch = false;
            isConnecting = false;
            gameEnded = false;
            enforceArenaDeckRules(); 
        } else if(view === 'shop'){
            shopViewEl.style.display = 'flex';
            
            if(socket) socket.disconnect();
            isInMatch = false;
            isConnecting = false;
            gameEnded = false;
        } else if(view === 'game'){
            gameBoardEl.style.display = 'flex';
            initMultiplayer();
        }
        
        updateUserNameDisplay(view);
        
        updateAll();
        updateButtonStates();
    }

    document.getElementById('shopBtn').onclick = () => changeView('shop');
    document.getElementById('deckEditorBtn').onclick = () => changeView('deck');
    document.getElementById('playBtn').onclick = () => {
        if (isConnecting || isInMatch || gameEnded) return; 
        changeView('game');
    };
    document.getElementById('updateLogBtn').onclick = showUpdateLogModal;
    document.getElementById('arenasBtn').onclick = showArenaModal;
    document.getElementById('forfeitBtn').onclick = handleForfeit;
    document.getElementById('profileBtn').onclick = showProfileModal;
    document.getElementById('settingsBtn').onclick = showSettingsModal;
    document.getElementById('friendsBtn').onclick = showFriendsModal; // NEW

    // --- MODAL FUNCTIONS (Existing) ---
    function renderUpdateLogs() {
        const logContentEl = document.getElementById('logContent');
        logContentEl.innerHTML = UPDATE_LOGS.map(log => `
            <div class="update-log-item">
                <h3>Version ${log.version} <span style="font-size: 0.7em; color: var(--muted); float: right;">(${log.date})</span></h3>
                <ul>
                    ${log.changes.map(change => `<li>${change}</li>`).join('')}
                </ul>
            </div>
        `).join('');
    }

    function showUpdateLogModal() {
        renderUpdateLogs();
        updateLogModalEl.style.display = 'flex'; 
    }
    
    function showArenaModal() {
        const arenaContentEl = document.getElementById('arenaContent');
        arenaContentEl.innerHTML = ''; 
        const arenaList = document.createElement('div');
        arenaList.className = 'arena-list';
        
        const currentArenaId = getCurrentArena().id;

        ARENAS.forEach(arena => {
            const isUnlocked = trophies >= arena.minTrophies;
            const isCurrent = arena.id === currentArenaId;

            const cardNames = arena.unlockCardIds.map(id => {
                const card = CARD_TEMPLATES.find(c => c.id === id);
                return card ? `${card.emoji} ${card.name}` : '?';
            });
            const cardHtml = cardNames.length > 0 ? `<div class="unlocked-cards">**Unlocks:** ${cardNames.join(', ')}</div>` : '<div>(No new cards)</div>';

            const item = document.createElement('div');
            item.className = `arena-item ${isCurrent ? 'current-arena' : ''} ${!isUnlocked ? 'locked' : ''}`;
            item.style.background = arena.background;

            item.innerHTML = `
                <h3>üèÜ ${arena.name}</h3>
                <p class="trophy-req">Requires: ${arena.minTrophies}+ Trophies</p>
                ${isUnlocked ? cardHtml : '<div class="unlocked-cards" style="color:#e74c3c;">**LOCKED**</div>'}
                ${isCurrent ? '<p style="font-weight: bold; color: yellow;">-- YOUR CURRENT ARENA --</p>' : ''}
            `;
            arenaList.appendChild(item);
        });

        arenaContentEl.appendChild(arenaList);
        arenasModalEl.style.display = 'flex'; 
    }

    function showProfileModal() {
        const profileContentEl = document.getElementById('profileContent');
        const currentArena = getCurrentArena();
        
        const deckCards = currentDeck.filter(Boolean).map(id => {
            const card = CARD_TEMPLATES.find(c => c.id === id);
            return card ? `${card.emoji} ${card.name}` : '?';
        });
        
        const equippedTag = getTagByName(globalState.equippedTag);

        profileContentEl.innerHTML = `
            <div style="display: flex; gap: 20px; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 20px; margin-bottom: 20px;">
                <div style="font-size: 60px; width: 80px; height: 80px; border-radius: 50%; background: #34495e; display: flex; align-items: center; justify-content: center;">
                    ${globalState.profilePic}
                </div>
                <div>
                    <h3 style="margin: 0; font-size: 1.8em;">${userName}</h3>
                    <p style="margin: 0; color: var(--muted); font-size: 0.9em;">ID: ${globalState.playerID}</p>
                    <p style="margin: 5px 0 0 0; font-size: 1.1em; font-weight: bold;">Tag: <span style="color: ${equippedTag.color};">${equippedTag.emoji} [${equippedTag.name}]</span></p>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="background: rgba(255, 152, 0, 0.1); padding: 10px; border-radius: 8px;">
                    <p style="margin: 0; color: var(--trophy-color); font-weight: bold;">Trophies: üèÜ ${trophies}</p>
                    <p style="margin: 0; font-size: 0.9em;">Max Trophies: üåü ${globalState.maxTrophies}</p>
                </div>
                <div style="background: rgba(110, 231, 183, 0.1); padding: 10px; border-radius: 8px;">
                    <p style="margin: 0; color: var(--accent); font-weight: bold;">Arena: ${currentArena.name}</p>
                    <p style="margin: 0; font-size: 0.9em;">Trophy Range: ${currentArena.minTrophies}+</p>
                </div>
            </div>

            <h4 style="margin-top: 25px; color: var(--accent);">Match Statistics:</h4>
            <div style="display: flex; justify-content: space-around; text-align: center; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;">
                <div><strong style="color: limegreen;">Wins:</strong> ${globalState.wins}</div>
                <div><strong style="color: red;">Losses:</strong> ${globalState.losses}</div>
                <div><strong style="color: orange;">Forfeits:</strong> ${globalState.forfeits}</div>
            </div>

            <h4 style="margin-top: 25px; color: var(--accent);">Current Deck:</h4>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; padding: 10px; border: 1px dashed rgba(255,255,255,0.1); border-radius: 8px;">
                ${deckCards.map(card => `<div style="text-align: center; font-size: 1.2em;">${card}</div>`).join('')}
                ${Array(8 - deckCards.length).fill(0).map(() => `<div style="color: var(--muted); text-align: center;">Empty Slot</div>`).join('')}
            </div>
        `;

        document.getElementById('profileModal').style.display = 'flex';
    }

    // SETTINGS MODAL FUNCTIONS
    function renderSettingsModal() {
        document.getElementById('newUsernameInput').value = userName;
        document.getElementById('profilePicPreview').textContent = globalState.profilePic;

        const idStatusEl = document.getElementById('idChangeStatus');
        const idBtnEl = document.getElementById('changeIdBtn');

        if (globalState.idChangeUsed) {
            idStatusEl.textContent = `Status: Used (ID: ${globalState.playerID})`;
            idStatusEl.style.color = 'red';
            idBtnEl.disabled = true;
            idBtnEl.style.background = '#333';
        } else {
            idStatusEl.textContent = 'Status: Available (One-time change)';
            idStatusEl.style.color = 'limeGreen';
            idBtnEl.disabled = false;
            idBtnEl.style.background = '#e74c3c';
        }
        
        // TAGS RENDER LOGIC
        const tagSelect = document.getElementById('tagSelect');
        tagSelect.innerHTML = ''; // Clear previous options

        globalState.unlockedTags.forEach(tagName => {
            const tag = getTagByName(tagName);
            const option = document.createElement('option');
            option.value = tagName;
            option.textContent = `${tag.emoji} ${tagName}`;
            if (tagName === globalState.equippedTag) {
                option.selected = true;
            }
            tagSelect.appendChild(option);
        });

        const equippedTag = getTagByName(globalState.equippedTag);
        document.getElementById('equippedTagPreview').innerHTML = `Current Tag: <span style="color: ${equippedTag.color};">${equippedTag.emoji} [${equippedTag.name}]</span>`;
    }

    function showSettingsModal() {
        if (isInMatch || isConnecting || gameEnded) {
            alert("Please wait for the current match state to resolve before changing settings.");
            return;
        }
        renderSettingsModal();
        document.getElementById('settingsModal').style.display = 'flex';
    }

    function changeUsername() {
        const newName = document.getElementById('newUsernameInput').value.trim();
        if (newName && newName.length >= 3 && newName.length <= 15) {
            
            // BLACKLIST CHECK
            const lowerCaseName = newName.toLowerCase();
            const hasBlacklistedWord = BLACKLISTED_WORDS.some(word => lowerCaseName.includes(word));
            
            if (hasBlacklistedWord) {
                alert("Error: Username contains blacklisted or inappropriate language.");
                return;
            }

            userName = newName;
            // Update the user in the mock pool as well
            const userInPool = MOCK_FRIENDS_POOL.find(u => u.isUser);
            if (userInPool) userInPool.username = newName;

            saveGameData();
            updateAll();
            alert(`Username successfully changed to ${userName}!`);
            document.getElementById('settingsModal').style.display = 'none';
        } else {
            alert("Username must be between 3 and 15 characters.");
        }
    }

    function changeProfilePic() {
        const newPic = PROFILE_EMOJIS[Math.floor(Math.random() * PROFILE_EMOJIS.length)];
        globalState.profilePic = newPic;
        // Update the user in the mock pool as well
        const userInPool = MOCK_FRIENDS_POOL.find(u => u.isUser);
        if (userInPool) userInPool.profilePic = newPic;
        
        saveGameData();
        renderSettingsModal(); 
        alert(`Profile picture changed to ${newPic}!`);
    }

    function changePlayerId() {
        if (globalState.idChangeUsed) {
            alert("You have already used your one-time ID change!");
            return;
        }

        if (confirm("Are you SURE you want to change your Player ID? This can only be done ONCE!")) {
            const oldId = globalState.playerID;
            globalState.playerID = generatePlayerID();
            globalState.idChangeUsed = true;
            
            // Update the user in the mock pool as well
            const userInPool = MOCK_FRIENDS_POOL.find(u => u.id === oldId);
            if (userInPool) userInPool.id = globalState.playerID;

            saveGameData();
            renderSettingsModal(); 
            alert(`Player ID successfully changed to ${globalState.playerID}! You cannot change it again.`);
            updateAll();
        }
    }
    
    function equipSelectedTag() {
        const tagSelect = document.getElementById('tagSelect');
        const selectedTag = tagSelect.value;
        
        if (globalState.equippedTag !== selectedTag) {
            globalState.equippedTag = selectedTag;
            saveGameData();
            updateAll();
            renderSettingsModal(); 
            alert(`Tag equipped: [${selectedTag}]`);
        }
    }


// --- MULTIPLAYER SETUP ---
function initMultiplayer() {
    // 1. Validation Check 
    if(currentDeck.filter(Boolean).length !== 8) {
        alert("Your deck must have exactly 8 cards to play!");
        changeView('deck');
        return;
    }
    
    // 2. SOCKET INITIALIZATION (New Live Logic)
    if (socket) {
        // Disconnect any existing socket before creating a new one
        socket.disconnect(); 
    }
    
  // Inside initMultiplayer()
// ...
    // 1. Initialize the Socket Connection
    socket = io(RENDER_SERVER_URL, { 
        query: {
            playerId: globalState.playerID // Sends your player ID
        }
    });
// ...

    // Setup listeners for the new Friends System logic
    setupFriendRequestListeners(); 
    
    // 3. Socket Event Handlers (Replacing the Mock Timeout)
    socket.on('connect', () => { 
        console.log('‚úÖ Connected to live Mini Royale Server! (ID: ' + socket.id + ')'); 
        displayStatusMessage('Connected! Searching for opponent...', 3000);
    });

    socket.on('disconnect', () => { 
        console.log('‚ùå Disconnected from server.'); 
        displayStatusMessage('Lost connection to server.', 3000);
        isInMatch = false;
        isConnecting = false;
        updateButtonStates();
    });

    // You will need a listener here: socket.on('matchFound', ...) to start the game!
    
    // 4. Client State Setup (Stays the same)
    isConnecting = true; 
    updateButtonStates();

    renderArena('Starting Match Simulation...');
    
    // Reset game state 
    gameState.timer = 180;
    gameState.elixir = 5.0;
    gameState.placedUnits = [];
    gameState.placementBoundary = 0.5;
    gameState.towers.player = JSON.parse(JSON.stringify(towerConfig));
    gameState.towers.opponent = JSON.parse(JSON.stringify(towerConfig));
    gameEnded = false;
    selectedCardId = null; 
    
    // Card Cycling Setup
    const shuffledDeck = shuffleArray([...currentDeck.filter(Boolean)]);
    gameState.playerHand = shuffledDeck.slice(0, 4); 
    gameState.drawPile = shuffledDeck.slice(4); 
    gameState.discardPile = [];


    // üí• The old setTimeout block that simulated the connection has been REMOVED!
    // The game logic will now wait for a server event to truly start the match.
}

    // --- CLICK-TO-SELECT / CLICK-TO-PLACE LOGIC ---
    arenaEl.addEventListener('click', (e) => {
        if (!isInMatch || gameEnded || selectedCardId === null) {
            if (selectedCardId === null && isInMatch) {
                displayStatusMessage('Select a card from your hand first!', 1500);
            }
            return;
        }

        const placedCardId = selectedCardId;
        const arenaHeight = arenaEl.clientHeight;
        const clickYPercent = e.offsetY / arenaHeight;
        const card = CARD_TEMPLATES.find(c => c.id === placedCardId);
        
        // Elixir check 
        if (!card || card.cost > gameState.elixir) {
             selectedCardId = null;
             renderHand(); 
             displayStatusMessage('Error: Not enough Elixir to place card!', 3000);
             return;
        }


        let isValidPlacement = true;
        if (card.type === 'troop') {
             if (clickYPercent < gameState.placementBoundary) {
                isValidPlacement = false;
             }
        }

        if (isValidPlacement) {
            
            gameState.elixir = Math.max(0, gameState.elixir - card.cost);

            if (card.type === 'troop') {
                
                const unitsToSpawn = card.unitCount;

                for (let i = 0; i < unitsToSpawn; i++) {
                    let posX = e.offsetX;
                    let posY = e.offsetY;
                    
                    if (unitsToSpawn > 1) {
                        posX += (Math.random() - 0.5) * 40; 
                        posY += (Math.random() - 0.5) * 40;
                    }
                    
                    gameState.placedUnits.push({
                        id: Date.now() + Math.random() + i, 
                        card: card, 
                        hp: card.unitHp, 
                        position: { x: posX, y: posY }, 
                        owner: 'player',
                        attackTimer: 0 
                    });
                }
                
                mockOpponentPlacement(e.offsetX, e.offsetY); 

            } else if (card.type === 'spell') {
                const spellRadius = 100;
                
                Object.entries(gameState.towers['opponent']).forEach(([key, data]) => {
                    const towerPos = getTowerPosition('opponent', key);
                    if (distance(towerPos, {x: e.offsetX, y: e.offsetY}) <= spellRadius) {
                        data.health = Math.max(0, data.health - card.damage);
                        updatePlacementBoundary();
                    }
                });
                
                gameState.placedUnits.filter(u => u.owner === 'opponent' && u.card.type === 'troop').forEach(unit => {
                    if (distance(unit.position, {x: e.offsetX, y: e.offsetY}) <= spellRadius) {
                        unit.hp = Math.max(0, unit.hp - card.damage);
                    }
                });
                
                const tempSpellEffect = {
                    id: Date.now() + Math.random(),
                    card: card,
                    position: { x: e.offsetX, y: e.offsetY },
                    owner: 'effect',
                };
                gameState.placedUnits.push(tempSpellEffect); 
                setTimeout(() => {
                    gameState.placedUnits = gameState.placedUnits.filter(u => u.id !== tempSpellEffect.id);
                    renderArena(); 
                }, 250); 
            }

            const placedCardIndexInHand = gameState.playerHand.indexOf(placedCardId);
            if (placedCardIndexInHand !== -1) {
                gameState.playerHand.splice(placedCardIndexInHand, 1);
                gameState.discardPile.push(placedCardId); 
                
                let replacementCardId = gameState.drawPile.shift(); 
                
                if (!replacementCardId && gameState.discardPile.length > 0) {
                    gameState.drawPile = shuffleArray(gameState.discardPile);
                    gameState.discardPile = [];
                    replacementCardId = gameState.drawPile.shift();
                }

                if (replacementCardId) {
                     gameState.playerHand.push(replacementCardId); 
                }
            }


            clickSound.currentTime = 0;
            clickSound.play().catch(e => console.log("Sound play prevented: ", e));

            selectedCardId = null; 
            
            renderHand(); 
            renderArena();
        } else {
            displayStatusMessage('Cannot place troop here: outside your territory!', 3000); 
        }
    });


    // --- GAME RENDER FUNCTIONS ---
    function createTowerEl(towerData, type, player) {
        const el = document.createElement('div');
        el.className = `tower ${type} ${player} ${towerData.health <= 0 ? 'destroyed' : ''}`;
        el.style.opacity = 1; 
        
        const healthPercent = (towerData.health / towerData.maxHealth) * 100;
        
        el.innerHTML = `
            <div class="health-bar"><div class="health-fill" style="width: ${healthPercent}%"></div></div>
            <div class="icon">${towerData.emoji}</div>
            <div style="font-size: 10px;">${Math.max(0, Math.floor(towerData.health))}</div>
        `;
        
        return el;
    }
    
    function renderUnits() {
        unitContainerEl.innerHTML = ''; 

        gameState.placedUnits.forEach(unit => {
            const card = unit.card;
            const unitStyle = getUnitStyle(card); 
            
            const unitEl = document.createElement('div');
            unitEl.className = `unit ${unit.owner}`;
            
            unitEl.style.left = `${unit.position.x}px`;
            unitEl.style.top = `${unit.position.y}px`;
            unitEl.style.transform = 'translate(-50%, -50%)'; 

            if (unit.owner === 'effect') {
                unitEl.style.width = '100px';
                unitEl.style.height = '100px';
                unitEl.style.borderRadius = '50%';
                unitEl.style.background = card.name.includes('Fire') ? 'radial-gradient(circle, rgba(255, 69, 0, 0.7), transparent)' : 'radial-gradient(circle, rgba(0, 191, 255, 0.7), transparent)';
                unitEl.style.borderColor = 'transparent';
                unitEl.style.boxShadow = '0 0 20px rgba(255,255,255,0.7)';
                unitEl.style.fontSize = '34px';
                unitEl.style.zIndex = '50';
                unitEl.innerHTML = `<div class="card-emoji-icon">${card.emoji}</div>`;

            } else if (card.type === 'troop') {
                const maxUnitHp = card.unitHp; 
                const healthPercent = (unit.hp / maxUnitHp) * 100;
                
                unitEl.style.width = `${unitStyle.size}px`;
                unitEl.style.height = `${unitStyle.size}px`;
                unitEl.style.borderRadius = unitStyle.shape;
                unitEl.style.fontSize = `${unitStyle.size/2}px`;
                
                let unitBackground = '';

                if (unit.owner === 'player') {
                    unitBackground = unitStyle.baseColor;
                    unitEl.style.borderColor = `rgba(33, 150, 243, 0.9)`;
                } else { 
                    unitBackground = '#e84118'; 
                    unitEl.style.borderColor = `rgba(255, 51, 51, 0.9)`;
                }

                unitEl.style.background = unitBackground;
                
                unitEl.style.boxShadow = `0 ${unitStyle.size/8}px ${unitStyle.size/3}px rgba(0,0,0,0.8), inset 0 0 ${unitStyle.size/4}px rgba(255,255,255,0.4)`;

                unitEl.innerHTML = `
                    <div class="unit-health-bar"><div class="unit-health-fill" style="width: ${healthPercent}%"></div></div>
                    <div class="card-emoji-icon">${unitStyle.emoji}</div>
                `;
            }

            unitContainerEl.appendChild(unitEl);
        });
    }


    function renderArena(message = null) {
        Array.from(arenaEl.children).forEach(child => {
            if (child.classList.contains('tower')) 
            {
                child.remove();
            }
        });

        const towerSetup = {
            player: {
                king: { type: 'king', left: '50%', transform: 'translate(-50%)', bottom: '10px' },
                princessL: { type: 'princess', left: '25%', transform: 'translate(-50%)', bottom: '10px' },
                princessR: { type: 'princess', right: '25%', transform: 'translate(50%)', bottom: '10px' }
            },
            opponent: {
                king: { type: 'king', left: '50%', transform: 'translate(-50%)', top: '10px' },
                princessL: { type: 'princess', left: '25%', transform: 'translate(-50%)', top: '10px' },
                princessR: { type: 'princess', right: '25%', transform: 'translate(50%)', top: '10px' }
            }
        };

        for (const player in towerSetup) {
            for (const key in towerSetup[player]) {
                const config = towerSetup[player][key];
                const data = gameState.towers[player][key];
                const towerEl = createTowerEl(data, config.type, player);
                Object.assign(towerEl.style, config);
                arenaEl.appendChild(towerEl);
            }
        }
        
        renderUnits(); 

        placementLineEl.style.top = `${gameState.placementBoundary * 100}%`;
        
        if (message) {
            displayStatusMessage(message, 5000); 
        }
        
        renderElixir();
    }
    
    function renderHand() {
        const handDisplayEl = document.getElementById('handDisplay');
        handDisplayEl.innerHTML = '';
        
        gameState.playerHand.forEach((cardId, index) => {
            const card = CARD_TEMPLATES.find(c => c.id === cardId);
            const container = document.createElement('div');
            container.className = 'hand-card-container';

            const cardEl = document.createElement('div');
            cardEl.className = 'hand-card';
            cardEl.dataset.id = cardId;
            cardEl.dataset.index = index; 
            cardEl.style.background = colorForId(card.id);
            
            let canPlay = card.cost <= gameState.elixir;

            if (!canPlay) {
                cardEl.classList.add('not-enough-elixir');
            } else {
                cardEl.classList.remove('not-enough-elixir');
            }
            
            if (selectedCardId === cardId) {
                cardEl.classList.add('selected'); 
            }
            
            cardEl.addEventListener('click', (e) => {
                if (!isInMatch || gameEnded) return;

                const clickedCard = CARD_TEMPLATES.find(c => c.id === cardId);

                if (selectedCardId === cardId) {
                    selectedCardId = null;
                } 
                else {
                    if (clickedCard.cost > gameState.elixir) {
                        displayStatusMessage('Not enough Elixir!');
                        return;
                    }
                    selectedCardId = cardId;
                    displayStatusMessage(`Selected ${clickedCard.name}`, 1500);
                }
                
                renderHand();
            });

            cardEl.innerHTML = `
                <div class="card-emoji">${card.emoji}</div>
                <div class="cost-badge">${card.cost}</div>
                <div style="font-size: 14px; color: #fff; margin-top: 5px;">${card.name}</div>
            `;
            
            container.appendChild(cardEl);
            handDisplayEl.appendChild(container);
        });
    }

    function renderElixir() {
        const currentElixir = Math.floor(gameState.elixir);
        const fractionalElixir = (gameState.elixir % 1).toFixed(1).substring(1);
        
        elixirFillEl.style.width = `${(gameState.elixir / gameState.maxElixir) * 100}%`;
        elixirCounterEl.innerHTML = `<span>${currentElixir}</span><span style="font-size: 18px; opacity: 0.7;">${fractionalElixir}</span> / ${gameState.maxElixir}`;
    }


    // --- GAME CLOCK & RESOURCE SIMULATION (Client-Side) ---
    function updateGameClock() {
        if (gameState.timer > 0) {
            gameState.timer--;
            let minutes = Math.floor(gameState.timer / 60);
            let seconds = gameState.timer % 60;
            if (seconds < 10) seconds = '0' + seconds;
            document.getElementById('timerDisplay').textContent = `${minutes}:${seconds}`;
        } else {
            document.getElementById('timerDisplay').textContent = "0:00 (Overtime!)";
            if(!checkWinCondition()) {
                 endGame('draw');
            }
        }
    }
    
    let elixirRate = 0.33;
    function updateElixir() {
        if (gameState.elixir < gameState.maxElixir) {
            const rateMultiplier = gameState.timer <= 120 ? 2 : 1; 
            gameState.elixir = Math.min(gameState.maxElixir, gameState.elixir + (elixirRate * rateMultiplier));
        }
        renderElixir();
        renderHand();
    }


    // --- DECK & SHOP LOGIC ---
    let page=0;
    const pageSize=8; 
    function renderPool(){
      poolGrid.innerHTML='';
      
      const maxUnlockedCardId = CARD_TEMPLATES.filter((_, i) => unlockedCards[i]).map(c => c.id).reduce((max, id) => Math.max(max, id), 0);
      
      CARD_TEMPLATES.slice(page * pageSize, (page + 1) * pageSize).forEach(card => {
        const cardUnlockInfo = getCardUnlockInfo(card.id);
        const playerCurrentArenaId = getCurrentArena().id;
        
        let isLocked = !unlockedCards[card.id - 1] && cardUnlockInfo.arenaId > playerCurrentArenaId; 
        
        if (card.id <= 12) isLocked = false; 

        const el=document.createElement('div');
        el.className='card';
        el.draggable=!isLocked; 
        el.dataset.id=card.id;
        
        if (isLocked) {
             el.classList.add('locked');
        } 
        
        el.innerHTML=`<div class="art" style="background:${colorForId(card.id)}">${card.emoji}</div><div class="meta"><div>${card.name}</div><div>${card.cost}</div>`;
        
        if (!el.classList.contains('locked')) {
            el.addEventListener('dragstart',e=>e.dataTransfer.setData('text/plain',card.id));
            el.addEventListener('click',()=>addCard(card.id));
        }

        poolGrid.appendChild(el);
      });
      
      const filteredCardsLength = CARD_TEMPLATES.length;
      const maxPages = Math.ceil(filteredCardsLength / pageSize);
      document.getElementById('nextPage').style.opacity = page < maxPages - 1 ? 1 : 0.5;
      document.getElementById('prevPage').style.opacity = page > 0 ? 1 : 0.5;
    }

    document.getElementById('nextPage').onclick=()=>{if(page<Math.ceil(CARD_TEMPLATES.length/pageSize)-1){page++;renderPool()}};
    document.getElementById('prevPage').onclick=()=>{if(page>0){page--;renderPool()}};


    function addCard(id){
      if(currentDeck.includes(id)) return displayStatusMessage('Card already in deck!'); 
      
      const cardUnlockArenaId = CARD_UNLOCK_MAP[id];
      const playerCurrentArenaId = getCurrentArena().id;
      if (cardUnlockArenaId > playerCurrentArenaId) {
        alert(`Cannot add this card! It unlocks in Arena ${cardUnlockArenaId} (${ARENAS[cardUnlockArenaId].name}), and you are currently in Arena ${playerCurrentArenaId} (${getCurrentArena().name}).`);
        return;
      }
      
      const idx=currentDeck.findIndex(x=>x===null);
      if(idx===-1)return displayStatusMessage('Deck full');
      currentDeck[idx]=id;
      saveGameData(); 
      updateAll();
    }

    function renderDeckSlots(){
      deckSlotsEl.innerHTML='';
      for(let i=0;i<8;i++){
        const slot=document.createElement('div');
        slot.className='deck-slot';
        if(currentDeck[i]){
          const c=CARD_TEMPLATES.find(x=>x.id===currentDeck[i]);
          const el=document.createElement('div'); el.className='card'; el.style.width='90%'; el.style.height='90%'; el.innerHTML=`<div class="art" style="background:${colorForId(c.id)}">${c.emoji}</div><div class="meta"><div>${c.name}</div><div>${c.cost}</div>`;
          slot.appendChild(el);
          slot.onclick = () => { 
             currentDeck[i] = null; 
             saveGameData(); 
             updateAll(); 
          };
        }else{
          slot.textContent='Drop card';
          slot.onclick = null;
        }

        slot.addEventListener('dragover',e=>e.preventDefault());
        slot.addEventListener('drop',e=>{
            e.preventDefault(); 
            const id=parseInt(e.dataTransfer.getData('text/plain')); 
            
            if (!id || currentDeck.includes(id)) {
                 displayStatusMessage('Card already in deck or invalid drop!');
                 return;
            }
            
            const cardUnlockArenaId = CARD_UNLOCK_MAP[id];
            const playerCurrentArenaId = getCurrentArena().id;
            if (cardUnlockArenaId > playerCurrentArenaId) {
              alert(`Cannot add this card! It unlocks in Arena ${cardUnlockArenaId} (${ARENAS[cardUnlockArenaId].name}), and you are currently in Arena ${playerCurrentArenaId} (${getCurrentArena().name}).`);
              return;
            }

            if (id) {
                currentDeck[i]=id; 
                saveGameData(); 
                updateAll();
            }
        });

        deckSlotsEl.appendChild(slot);
      }
    }

    function renderDeckPreview(){
      deckPreview.innerHTML='';
      currentDeck.forEach(id=>{
        const s=document.createElement('div'); s.className='slot'; s.textContent=id?CARD_TEMPLATES.find(c=>c.id===id).emoji:'+';
        deckPreview.appendChild(s);
      })
    }

    function avgCost(){
      const arr=currentDeck.filter(Boolean).map(id=>CARD_TEMPLATES.find(c=>c.id===id).cost);
      return arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(2):'‚Äî';
    }

    function updateAll(){
        renderPool();
        renderDeckSlots();
        renderDeckPreview();
        document.getElementById('avgCost').textContent=avgCost();
        goldDisplay.textContent = `üí∞ ${gold}`;
        gemsDisplay.textContent = `üíé ${gems}`;
        trophyDisplay.textContent = `üèÜ ${trophies}`; 
        
        updateUserNameDisplay(currentView);

        if (currentView === 'game') {
            updatePlacementBoundary(); 
            renderArena();
            renderHand(); 
        }
        updateButtonStates();
    }
    
    // Shop functions (mock)
    function buyChest(cards, cost) {
        if (gems >= cost) {
            gems -= cost;
            let unlockedCount = 0;
            
            const playerCurrentArenaId = getCurrentArena().id;

            // Filter available cards: those from an arena the player has reached or lower, but are not yet unlocked by the shop system (unlockedCards)
            const availableToUnlock = CARD_TEMPLATES
                .filter(card => card.unlockArenaId <= playerCurrentArenaId && !unlockedCards[card.id - 1])
                .map(card => card.id);
                
            shuffleArray(availableToUnlock);

            for (let i = 0; i < cards && i < availableToUnlock.length; i++) {
                const cardId = availableToUnlock[i];
                unlockedCards[cardId - 1] = true;
                unlockedCount++;
            }

            saveGameData(); 
            alert(`You bought a chest and unlocked ${unlockedCount} card(s)!`);
            updateAll();
        } else {
            alert("Not enough Gems!");
        }
    }
    
    function buyTagChest() {
        if (gems < TAG_CHEST_COST) {
            alert("Not enough Gems to buy a Tag Chest! (Requires üíé 100)");
            return;
        }
        
        gems -= TAG_CHEST_COST;
        
        // Filter out tags already unlocked (and 'None' and 'CREATOR')
        const availableTags = TAG_RARITIES.filter(tag => !globalState.unlockedTags.includes(tag.name));

        if (availableTags.length === 0) {
            alert("You have already unlocked all available unique tags! Gems refunded.");
            gems += TAG_CHEST_COST; // Refund
            updateAll();
            return;
        }

        // Rarity calculation
        const totalRarity = availableTags.reduce((sum, tag) => sum + tag.rarity, 0);
        let randomNumber = Math.random() * totalRarity;
        let newTag = null;

        for (const tag of availableTags) {
            if (randomNumber < tag.rarity) {
                newTag = tag;
                break;
            }
            randomNumber -= tag.rarity;
        }

        if (newTag) {
            globalState.unlockedTags.push(newTag.name);
            saveGameData();
            alert(`üéâ Congratulations! You unlocked the **${newTag.name}** tag! ${newTag.emoji}`);
        } else {
            // Fallback: If floating point math somehow fails, grant the rarest available
            newTag = availableTags.sort((a, b) => a.rarity - b.rarity)[0];
            globalState.unlockedTags.push(newTag.name);
            saveGameData();
            alert(`üéâ Congratulations! You unlocked the **${newTag.name}** tag! ${newTag.emoji}`);
        }

        updateAll();
    }
    
    function exchangeGold(g, c) {
        if (gold >= g) {
            gold -= g;
            gems += c;
            saveGameData(); 
            alert(`${g} Gold exchanged for ${c} Gems!`);
            updateAll();
        } else {
            alert("Not enough Gold!");
        }
    }

    // --- INITIALIZATION ---
    loadGameData();
    renderPool(); 
    updateAll();
    changeView('deck'); 
  </script>
</body>
</html>
</html>










